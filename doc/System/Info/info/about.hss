[Main]
Title=About TIGCC

[Top]
TIGCC is our attempt to make it possible to program in C for the TI-89 and TI-92 Plus. To do this, we originally recompiled a version of GCC-M68k (which was found <A HREF="http://fiddes.net/coldfire/">here</A>) to make it work with the C calling convention used by TI's compiler. Then we wrote a linker to make it produce <CODE>.89z</CODE> or <CODE>.9xz</CODE> files. And since we also wanted to allow the use of assembly, we programmed it so that you can use the
<CODE>.asm</CODE> files and compile them with the A68k assembler. Finally we wrote <CODE>tigcc</CODE>, a program which will automatically call the necessary programs to compile everything you specify in the command line.
This was the first public release of TIGCC.
<BR><BR>
At that time, Zeljko Juric (i.e. me, because I am writing this documentation) was quite new in TI community (he bought his TI-89 in July 1999). Although he was a good ASM programmer (in Z80 and 80x86 assembler), he found ASM programming on TI calculators a bit unconfortable, so he started searching for a high-level language compiler for TI-89 (TI-Basic was too slow and somewhat limited). Some compilers were written, but they were quite primitive (one of them was usable anyway: Fargo Pascal, which is transformed later in Ultra Pascal). Then he found a first release of TIGCC...
<BR><BR>
Some testing proved that it produced quite usable code. But there was a complete lack of library functions. There was just one header file named <CODE>romcalls.h</CODE> which was partially usable only for "Doors" programming. Implemented romcalls were possible to use only under the "DoorsOS" kernel. As Zeljko was not a follower nor a lover of the "kernel" concept, he started to think how to use romcalls without any kernels. After a bit of researching, he suceeded to construct a rom-calling macro which worked independently of any kernel, by calling TIOS functions directly.
<BR><BR>
In the meantime, Xavier stopped the development of the still buggy linker for a while; that was why Niklas Brunlid corrected some of the bugs because he needed TIGCC for his project (Prosit). During this period, Zeljko started to research the (almost completely undocumented) TIOS entry points. He discovered that TIOS itself contains many very useful routines which were usually implemented in various external libraries for kernel-based programming. So the natural decision was to make a library of routines, based exclusively on TIOS entries, which would be usable for both kernel-less and kernel-based programming (and to document everything what was found, of course). This was how the <A HREF="$$INFOLINK(hdrindex)">TIGCC Library</A> was founded in the beginning of 2000.
<BR><BR>
After the release of the TIGCC Library, Xavier started to continue developing TIGCC, so integrating the library as an integral part of TIGCC was the next step. This way Zeljko became a member of TIGCC team. He continued to research the dark, deep, and (previously) unknown parts of the operating system to be able to upgrade the library with new routines. So, at the end of March, version 1.5 of the library was released, with a lot of new functions, and also with floating point support (although it had a few bugs at first).
<BR><BR>
For a long time, TIGCC was just a command line compiler. Sebastian Reichelt started developing a window-based <A HREF="$$INFOLINK(ide)">Integrated Environment</A> for TIGCC in April. First versions of it were quite simple, but later some more advanced options were added to it. In the meantime, Zeljko continued researching and developing. Many people pointed out that the lack of "standard" ANSI C library routines like "fopen" etc. was a big disadvantage of TIGCC, so Zeljko decided to implement them in the TIGCC library. The main problem was the impossibility of creating external archives of library routines (the linker did not support them). Then he discovered a black art of cast constructors which allowed implementing these routines in a quite efficient way, using extremely dirty hacks. The main goal
was that the routines which were not used in the program would not be part of the final executable in any way, but if the routines were used, they were supposed to be included only once. This behaviour was implemented successfully, so version 2.0 was released. This release included about 300 new functions compared to the previous release!
<BR><BR>
Finally, Xavier, Sebastian and Zeljko decided to put everything together and stop distributing various part of TIGCC (compiler, linker, library and environment) independently. Instead, starting from release 0.7, TIGCC contained everything packed in one file. The included library was now release 2.2 (which had stable floating point support, established in release 2.1).
<BR><BR>
The most important recent change was a complete recompilation of GCC using the sources from the official <A HREF="http://www.cygwin.com/">Cygwin</A> site. This recompilation made it possible to work on the compiler again, which was impossible before because the sources were lost. Native floating point support was implemented by Sebastian in November and December, while Zeljko created the appropriate library functions for this.
<BR><BR>
When Sebastian Reichelt and Kevin Kofler found and patched a working AmigaOS to COFF converter at the <A HREF="http://www.geekgadgets.org">Geek Gadgets</A> site, the linker was not needed as a true linker any more, but rather as a converter from the COFF to the TI executable format. Therefore Julien Muchembled contributed a converter of his own, which was much better than the previous <CODE>link</CODE>.
<BR><BR>
For TIGCC 0.95, Sebastian wrote a new linker, <CODE>ld-tigcc</CODE>, which, with Kevin's help, changed TIGCC a lot for the better, allowing to optimize any references between object files at link time, and even to merge constants and reorder sections. It also finally made BSS sections in nostub programs possible. More interesting features are still continuously being added to the linker.
<BR><BR>
After the TIGCC 0.95 release, the last thing missing from TIGCC was a C debugger. This prompted Kevin to work on integrating GDB into Romain Liévin's TiEmu emulator and adding support for it to TIGCC. The most powerful debugging information format supported by GCC and GDB, DWARF 2, was selected for the debugger.
<BR><BR>
Although the version you are using now has evolved from a lot of different little updates, it is more or less a complete, working product. Changes are still being made, though, and there is still a long way ahead for TIGCC.
