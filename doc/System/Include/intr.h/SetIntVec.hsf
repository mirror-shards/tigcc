[Main]
Name=SetIntVec
Type=Function
Subtype=Macro
Header Files=intr.h
Definition=void SetIntVec (long IntVec, INT_HANDLER Handler);
Real Definition=#define SetIntVec(i,h) ({asm volatile ("bclr.b #2,0x600001");(void) (*(INT_HANDLER*)(i) = (h));asm volatile ("bset.b #2,0x600001");})
See Also=GetIntVec, IntVecs, DEFINE_INT_HANDLER

[Description]
Sets an interrupt vector.

[Explanation]
SetIntVec sets the interrupt vector located at the absolute address
<I>IntVec</I> to the interrupt handler pointed to by
<I>Handler</I>. <I>Handler</I> should be either a value returned from
<A HREF="$$LINK(GetIntVec)">GetIntVec</A>, or the address of a user-defined interrupt
handler defined using <A HREF="$$LINK(DEFINE_INT_HANDLER)">DEFINE_INT_HANDLER</A>.
Note that <I>Handler</I> may not be the address of an ordinary C function.
<BR><BR>
Typical values of <I>IntVec</I> are given in the following table as enumerated
in the <A HREF="$$LINK(IntVecs)">IntVecs</A> enum:
<BR><BR>
<TABLE BORDER CELLPADDING="3">
<TR>
<TD><B>Address</B></TD><TD><B>Associated Constant</B></TD><TD><B>Triggered On</B></TD>
</TR>
<TR>
<TD>0x04</TD><TD>INT_VEC_RESET</TD><TD>Reset (contains pointer to OS entry point)</TD>
</TR>
<TR>
<TD>0x08</TD><TD>INT_VEC_BUS_ERROR</TD><TD>Bus error</TD>
</TR>
<TR>
<TD>0x0C</TD><TD>INT_VEC_ADDRESS_ERROR</TD><TD>Address error (accessing a short or long at an odd address)</TD>
</TR>
<TR>
<TD>0x10</TD><TD>INT_VEC_ILLEGAL_INSTRUCTION</TD><TD>Illegal instruction</TD>
</TR>
<TR>
<TD>0x14</TD><TD>INT_VEC_ZERO_DIVIDE</TD><TD>Division by zero</TD>
</TR>
<TR>
<TD>0x18</TD><TD>INT_VEC_CHK_INS</TD><TD>CHK instruction</TD>
</TR>
<TR>
<TD>0x1C</TD><TD>INT_VEC_TRAPV_INS</TD><TD>TRAPV instruction</TD>
</TR>
<TR>
<TD>0x20</TD><TD>INT_VEC_PRIVILEGE_VIOLATION</TD><TD>Privilege violation</TD>
</TR>
<TR>
<TD>0x24</TD><TD>INT_VEC_TRACE</TD><TD>Code Tracing</TD>
</TR>
<TR>
<TD>0x28</TD><TD>INT_VEC_LINE_1010</TD><TD>Special instructions generated by <A HREF="$$LINK(error.h/ER_throw)">ER_throw</A> (0xA???)</TD>
</TR>
<TR>
<TD>0x2C</TD><TD>INT_VEC_LINE_1111</TD><TD><A HREF="$$INFOLINK(httigcc/advanced_flinerom)">F-Line</A> instructions (0xF???)</TD>
</TR>
<TR>
<TD>0x3C</TD><TD>INT_VEC_UNINITIALIZED_INT</TD><TD>Uninitialized interrupt vector</TD>
</TR>
<TR>
<TD>0x60</TD><TD>INT_VEC_SPURIOUS_INT</TD><TD>Spurious interrupt</TD>
</TR>
<TR>
<TD>0x64</TD><TD>AUTO_INT_1</TD><TD>Main timer hardware interrupt running at approximately 350 Hz</TD>
</TR>
<TR>
<TD>0x68</TD><TD>AUTO_INT_2<BR>INT_VEC_KEY_PRESS</TD><TD>Key press (triggered periodically while key(s) other than 'ON' are held down; the rate depends both on battery strength and on which keys are being held down, and is usually in the ballpark of about 600 Hz)</TD>
</TR>
<TR>
<TD>0x6C</TD><TD>AUTO_INT_3</TD><TD>On most calculators, triggers once per second if enabled using a certain instruction</TD>
</TR>
<TR>
<TD>0x70</TD><TD>AUTO_INT_4<BR>INT_VEC_LINK</TD><TD>Link port activity</TD>
</TR>
<TR>
<TD>0x74</TD><TD>AUTO_INT_5</TD><TD>System timer running at approximately 18 Hz (see <A HREF="$$LINK(PRG_setRate)">PRG_setRate</A>, <A HREF="$$LINK(PRG_setStart)">PRG_setStart</A>)</TD>
</TR>
<TR>
<TD>0x78</TD><TD>AUTO_INT_6<BR>INT_VEC_ON_KEY_PRESS</TD><TD>'ON' key press</TD>
</TR>
<TR>
<TD>0x7C</TD><TD>AUTO_INT_7<BR>INT_VEC_STACK_OVERFLOW</TD><TD>Stack overflow (actually results in Protected Memory Violation)</TD>
</TR>
</TABLE>
<BR>
All traps may be triggered manually using the TRAP assembler instruction.
<BR><BR>
<TABLE BORDER CELLPADDING="3">
<TR>
<TD><B>Address</B></TD><TD><B>Associated Constant</B></TD><TD><B>Default Behavior</B></TD>
</TR>
<TR>
<TD>0x80</TD><TD>TRAP_0</TD><TD>(unknown)</TD>
</TR>
<TR>
<TD>0x84</TD><TD>TRAP_1<BR>INT_VEC_INT_MASK</TD><TD>Change interrupt mask (bits 8-10 of %sr) to %d0.w, output old mask in %d0.l</TD>
</TR>
<TR>
<TD>0x88</TD><TD>TRAP_2<BR>INT_VEC_MANUAL_RESET</TD><TD>Reset calculator</TD>
</TR>
<TR>
<TD>0x8C</TD><TD>TRAP_3</TD><TD>(unknown)</TD>
</TR>
<TR>
<TD>0x90</TD><TD>TRAP_4<BR>INT_VEC_OFF</TD><TD>Turn the calculator off and wait for 'ON' key press</TD>
</TR>
<TR>
<TD>0x94</TD><TD>TRAP_5</TD><TD>(unknown)</TD>
</TR>
<TR>
<TD>0x98</TD><TD>TRAP_6</TD><TD>(unknown)</TD>
</TR>
<TR>
<TD>0x9C</TD><TD>TRAP_7</TD><TD>(unknown)</TD>
</TR>
<TR>
<TD>0xA0</TD><TD>TRAP_8</TD><TD>(unknown)</TD>
</TR>
<TR>
<TD>0xA4</TD><TD>TRAP_9</TD><TD>Access to various system routines</TD>
</TR>
<TR>
<TD>0xA8</TD><TD>TRAP_10<BR>INT_VEC_SELF_TEST</TD><TD>Enter self test</TD>
</TR>
<TR>
<TD>0xAC</TD><TD>TRAP_11<BR>INT_VEC_ARCHIVE</TD><TD>Print "Trap 11" and freeze</TD>
</TR>
<TR>
<TD>0xB0</TD><TD>TRAP_12</TD><TD>Put the processor in supervisor mode; return the previous value of the status register in <CODE>%d0:w</CODE></TD>
</TR>
<TR>
<TD>0xB4</TD><TD>TRAP_13</TD><TD>Print "Trap 13" and freeze</TD>
</TR>
<TR>
<TD>0xB8</TD><TD>TRAP_14</TD><TD>Print "Trap 14" and freeze</TD>
</TR>
<TR>
<TD>0xBC</TD><TD>TRAP_15<BR>INT_VEC_ER_THROW</TD><TD>Print "ER_throw" and freeze</TD>
</TR>
</TABLE>
<BR>
See <A HREF="$$LINK(DEFINE_INT_HANDLER)">DEFINE_INT_HANDLER</A> for an example of usage.
