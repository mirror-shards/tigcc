diff -Naur binutils-2.16.1.orig/bfd/config.bfd binutils-2.16.1-src/bfd/config.bfd
--- binutils-2.16.1.orig/bfd/config.bfd	Mon Jan 31 17:18:46 2005
+++ binutils-2.16.1-src/bfd/config.bfd	Thu Jun 30 23:40:16 2005
@@ -708,7 +708,6 @@
     ;;
   m68*-*-coff* | m68*-*-sysv*)
     targ_defvec=m68kcoff_vec
-    targ_selvecs="m68kcoff_vec versados_vec ieee_vec"
     ;;
   m68*-*-hpux*)
     targ_defvec=hp300hpux_vec
diff -Naur binutils-2.16.1.orig/gas/as.c binutils-2.16.1-src/gas/as.c
--- binutils-2.16.1.orig/gas/as.c	Thu Mar  3 01:29:52 2005
+++ binutils-2.16.1-src/gas/as.c	Thu Jun 30 23:40:16 2005
@@ -251,6 +251,10 @@
                       	  s      include symbols\n\
                       	  =FILE  list to FILE (must be last sub-option)\n"));
 
+/* (TIGCC 20030716) */
+  fprintf (stream, _("\
+  --all-relocs            output all relocs, implies --keep-locals (-L)\n"));
+
   fprintf (stream, _("\
   --alternate             initially turn on alternate macro syntax\n"));
   fprintf (stream, _("\
@@ -426,7 +430,8 @@
       OPTION_EXECSTACK,
       OPTION_NOEXECSTACK,
       OPTION_ALTERNATE,
-      OPTION_WARN_FATAL
+      OPTION_WARN_FATAL,
+      OPTION_ALL_RELOCS /* (TIGCC 20030716) */
     /* When you add options here, check that they do
        not collide with OPTION_MD_BASE.  See as.h.  */
     };
@@ -442,6 +447,8 @@
        necessary because -a=<FILE> is a valid switch but getopt would
        normally reject it since --alternate does not take an argument.  */
     ,{"a", optional_argument, NULL, 'a'}
+/* (TIGCC 20030716) */
+    ,{"all-relocs", no_argument, NULL, OPTION_ALL_RELOCS}
     ,{"defsym", required_argument, NULL, OPTION_DEFSYM}
     ,{"dump-config", no_argument, NULL, OPTION_DUMPCONFIG}
     ,{"emulation", required_argument, NULL, OPTION_EMULATION}
@@ -864,6 +871,12 @@
 
 	case 'X':
 	  /* -X means treat warnings as errors.  */
+	  break;
+
+	/* (TIGCC 20030716) */
+	case OPTION_ALL_RELOCS:
+	  flag_all_relocs = 1;
+	  flag_keep_locals = 1; /* implies -L */
 	  break;
 	}
     }
diff -Naur binutils-2.16.1.orig/gas/as.h binutils-2.16.1-src/gas/as.h
--- binutils-2.16.1.orig/gas/as.h	Wed Apr 13 19:58:40 2005
+++ binutils-2.16.1-src/gas/as.h	Thu Jun 30 23:40:16 2005
@@ -244,16 +244,22 @@
 
 #ifdef MANY_SEGMENTS
 #include "bfd.h"
-#define N_SEGMENTS 40
-#define SEG_NORMAL(x) ((x) >= SEG_E0 && (x) <= SEG_E39)
-#define SEG_LIST SEG_E0,SEG_E1,SEG_E2,SEG_E3,SEG_E4,SEG_E5,SEG_E6,SEG_E7,SEG_E8,SEG_E9,\
-		 SEG_E10,SEG_E11,SEG_E12,SEG_E13,SEG_E14,SEG_E15,SEG_E16,SEG_E17,SEG_E18,SEG_E19,\
-		 SEG_E20,SEG_E21,SEG_E22,SEG_E23,SEG_E24,SEG_E25,SEG_E26,SEG_E27,SEG_E28,SEG_E29,\
-		 SEG_E30,SEG_E31,SEG_E32,SEG_E33,SEG_E34,SEG_E35,SEG_E36,SEG_E37,SEG_E38,SEG_E39
+/* (TIGCC 20040625) 40 sections are definitely not enough for
+                    -ffunction-sections, -fdata-sections and the like.
+                    So I increased them to 120. -- Kevin Kofler
+   (TIGCC 20040905) And again to 1024. -- Kevin Kofler */
+#define N_SEGMENTS 1024
+#define SEG_NORMAL(x) ((x) >= SEG_E0 && (x) <= SEG_LAST)
+#define LIST_10_(decade) decade##0,decade##1,decade##2,decade##3,decade##4,decade##5,decade##6,decade##7,decade##8,decade##9
+#define LIST_FIRST_100_(century) LIST_10_(century),LIST_10_(century##1),LIST_10_(century##2),LIST_10_(century##3),LIST_10_(century##4),LIST_10_(century##5),LIST_10_(century##6),LIST_10_(century##7),LIST_10_(century##8),LIST_10_(century##9)
+#define LIST_100_(century) LIST_10_(century##0),LIST_10_(century##1),LIST_10_(century##2),LIST_10_(century##3),LIST_10_(century##4),LIST_10_(century##5),LIST_10_(century##6),LIST_10_(century##7),LIST_10_(century##8),LIST_10_(century##9)
+#define LIST_FIRST_1000_(millennium) LIST_FIRST_100_(millennium),LIST_100_(millennium##1),LIST_100_(millennium##2),LIST_100_(millennium##3),LIST_100_(millennium##4),LIST_100_(millennium##5),LIST_100_(millennium##6),LIST_100_(millennium##7),LIST_100_(millennium##8),LIST_100_(millennium##9)
+#define SEG_LIST LIST_FIRST_1000_(SEG_E),LIST_10_(SEG_E100),LIST_10_(SEG_E101),\
+		 SEG_E1020,SEG_E1021,SEG_E1022,SEG_E1023
 #define SEG_TEXT SEG_E0
 #define SEG_DATA SEG_E1
 #define SEG_BSS SEG_E2
-#define SEG_LAST SEG_E39
+#define SEG_LAST SEG_E1023
 #else
 #define N_SEGMENTS 3
 #define SEG_NORMAL(x) ((x) == SEG_TEXT || (x) == SEG_DATA || (x) == SEG_BSS)
@@ -294,8 +300,13 @@
 #ifdef BFD_ASSEMBLER
 #define segment_name(SEG)	bfd_get_section_name (stdoutput, SEG)
 #else
+/* (TIGCC 20040905) Allow arbitrary number of sections here. -- Kevin Kofler */
+#if 0
 extern char const *const seg_name[];
-#define segment_name(SEG)	seg_name[(int) (SEG)]
+#define segment_name(SEG)	seg_name[(int) (SEG)]*/
+#else
+char *segment_name PARAMS ((int));
+#endif
 #endif
 
 #ifndef BFD_ASSEMBLER
@@ -481,6 +492,9 @@
 
 extern enum debug_info_type debug_type;
 extern int use_gnu_debug_info_extensions;
+
+/* (TIGCC 20030716) True if all relocs should be retained.  */
+COMMON unsigned char flag_all_relocs; /* --all-relocs */
 
 /* Maximum level of macro nesting.  */
 extern int max_macro_nest;
diff -Naur binutils-2.16.1.orig/gas/config/obj-coff.c binutils-2.16.1-src/gas/config/obj-coff.c
--- binutils-2.16.1.orig/gas/config/obj-coff.c	Tue Mar  1 11:24:30 2005
+++ binutils-2.16.1-src/gas/config/obj-coff.c	Thu Jun 30 23:40:16 2005
@@ -1695,7 +1695,7 @@
      section alignment, then skip this step, as TICOFF does.  */
   size = bfd_get_section_size (sec);
   mask = ((bfd_vma) 1 << align_power) - 1;
-#if !defined(TICOFF)
+#if 0 /*!defined(TICOFF)*/
   if (size & mask)
     {
       bfd_vma new_size;
@@ -1834,14 +1834,20 @@
 /* This vector is used to turn a gas internal segment number into a
    section number suitable for insertion into a coff symbol table.
    This must correspond to seg_info_off_by_4.  */
+/* (TIGCC 20040625) 40 sections are definitely not enough for
+                    -ffunction-sections, -fdata-sections and the like.
+                    So I increased them to 120. -- Kevin Kofler */
 
 const short seg_N_TYPE[] =
 {				/* in: segT   out: N_TYPE bits */
+/* (TIGCC 20040905) Allow arbitrary number of sections here. -- Kevin Kofler */
+#if 0
   C_ABS_SECTION,
   1,    2,  3,   4,    5,   6,   7,   8,   9,  10,
   11,  12,  13,  14,  15,  16,  17,  18,  19,  20,
   21,  22,  23,  24,  25,  26,  27,  28,  29,  30,
   31,  32,  33,  34,  35,  36,  37,  38,  39,  40,
+#endif /*0*/
   C_UNDEF_SECTION,		/* SEG_UNKNOWN */
   C_UNDEF_SECTION,		/* SEG_GOOF */
   C_UNDEF_SECTION,		/* SEG_EXPR */
@@ -1851,6 +1857,13 @@
   C_REGISTER_SECTION,		/* SEG_REGISTER */
 };
 
+short SEGMENT_TO_SYMBOL_TYPE (n) int n;
+{
+  if (!n) return C_ABS_SECTION;
+  else if (SEG_NORMAL(n)) return n-SEG_E0+1;
+  else return seg_N_TYPE[n-(N_SEGMENTS+1)];
+}
+
 int function_lineoff = -1;	/* Offset in line#s where the last function
 				   started (the odd entry for line #0) */
 
@@ -1918,6 +1931,8 @@
  SEG_DEBUG,
  SEG_ABSOLUTE,
  SEG_UNKNOWN,
+/* (TIGCC 20040905) Allow arbitrary number of sections here. -- Kevin Kofler */
+#if 0
  SEG_E0,  SEG_E1,  SEG_E2,  SEG_E3,  SEG_E4,
  SEG_E5,  SEG_E6,  SEG_E7,  SEG_E8,  SEG_E9,
  SEG_E10, SEG_E11, SEG_E12, SEG_E13, SEG_E14,
@@ -1936,9 +1951,19 @@
  (segT) 0,
  (segT) 0,
  SEG_REGISTER
+#endif /*0*/
 };
 
-#define SEG_INFO_FROM_SECTION_NUMBER(x) (seg_info_off_by_4[(x)+4])
+static segT SEG_INFO_FROM_SECTION_NUMBER PARAMS ((int));
+
+static segT SEG_INFO_FROM_SECTION_NUMBER (n) int n;
+{
+  if (n<=0) return seg_info_off_by_4[n+4];
+  else if (n<=N_SEGMENTS) return n-1+SEG_E0;
+  else if (n<=N_SEGMENTS+6) return n-1;
+  else if (n==C_REGISTER_SECTION) return SEG_REGISTER;
+  else return 0;
+}
 
 static relax_addressT relax_align PARAMS ((relax_addressT, long));
 
@@ -2010,6 +2035,12 @@
 	    size += off;
 	  }
 	  break;
+    case rs_cfa:
+      size += frag->fr_fix + eh_frame_estimate_size_before_relax (frag);
+      break;
+    case rs_dwarf2dbg:
+      size += frag->fr_fix + dwarf2dbg_estimate_size_before_relax (frag);
+      break;
 	default:
 	  BAD_CASE (frag->fr_type);
 	  break;
@@ -2159,8 +2190,11 @@
 					S_GET_NAME (symbol_ptr));
 			    }
 
+/* (TIGCC 20030715) Don't convert references to references to the section symbol.
+   (TIGCC 20030805) ... except for local symbols!
+ -- Kevin Kofler  */
 			  dot = segment_info[S_GET_SEGMENT (symbol_ptr)].dot;
-			  if (dot)
+			  if (dot && S_IS_LOCAL(symbol_ptr))
 			    intr.r_symndx = dot->sy_number;
 			  else
 			    intr.r_symndx = symbol_ptr->sy_number;
@@ -2309,6 +2343,16 @@
 		    }
 
 		  break;
+
+		case rs_cfa:
+		  eh_frame_convert_frag (frag);
+		  goto have_converted_rs_fill;
+
+		case rs_dwarf2dbg:
+		  dwarf2dbg_convert_frag (frag);
+          /* fall through */
+
+		have_converted_rs_fill:
 		case rs_space:
 		case rs_fill:
 		case rs_align:
@@ -3218,6 +3262,11 @@
       tc_frob_coff_symbol (symbolP);
 #endif
 
+      /* (TIGCC 20040725) Clear the SF_LOCAL flag if the symbol is in a
+                          mergeable section. -- Kevin Kofler  */
+     if (segment_info[S_GET_SEGMENT (symbolP)].scnhdr.s_flags & STYP_MERGEABLE)
+       SF_CLEAR_LOCAL (symbolP);
+
       /* We must put the external symbols apart. The loader
 	 does not bomb if we do not. But the references in
 	 the endndx field for a .bb symbol are not corrected
@@ -3559,7 +3608,7 @@
   (!(FRCHAIN)->frch_next || (FRCHAIN)->frch_next->frch_seg != (SEG)	\
    ? get_recorded_alignment (SEG) : 0)
 #else
-#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 1
+#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 0 /*1*/
 #endif
 #endif
 
@@ -3767,7 +3816,9 @@
 {
   unsigned int i;
 
-#ifndef COFF_LONG_SECTION_NAMES
+/* (TIGCC 20040625) Use the full name, not the truncated name, for merging of
+                    identically-named sections. -- Kevin Kofler */
+#if 0 /*ndef COFF_LONG_SECTION_NAMES*/
   char buf[SCNNMLEN + 1];
 
   strncpy (buf, name, SCNNMLEN);
@@ -3870,6 +3921,9 @@
 		case 'w': flags |= STYP_DATA;   break;
 		case 'x': flags |= STYP_TEXT;   break;
 		case 'r': flags |= STYP_LIT;	break;
+/* (TIGCC 20040724) TIGCC COFF extensions for section flags -- Kevin Kofler */
+		case 'm': flags |= STYP_MERGEABLE;	break;
+		case 'u': flags |= STYP_UNALIGNED;	break;
 		default:
 		  as_warn(_("unknown section attribute '%c'"),
 			  *input_line_pointer);
@@ -4029,6 +4083,13 @@
       symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
       symbol_insert (symbolP, symbol_rootP, &symbol_rootP, &symbol_lastP);
     }
+
+  /* (TIGCC 20030717) In all-relocs mode, add an __ld_all_relocs symbol pointing
+                      to a dummy label in the text section. -- Kevin Kofler  */
+  if (flag_all_relocs) {
+    symbolP = symbol_new("__ld_all_relocs", SEG_TEXT, 0, &zero_address_frag);
+    S_SET_EXTERNAL(symbolP); /* make it an xdef */
+  }
 }
 
 /* Build a 'section static' symbol.  */
@@ -4344,10 +4405,13 @@
 #endif /* TC_I960 */
 	      add_number += S_GET_VALUE (add_symbolP) -
 		S_GET_VALUE (sub_symbolP);
-	      add_symbolP = NULL;
 
 	      if (!TC_FORCE_RELOCATION (fixP))
 		{
+		  /* (TIGCC 20030717) Zero out add_symbolP only if !TC_FORCE_RELOCATION.
+		                      -- Kevin Kofler  */
+		  add_symbolP = NULL;
+
 		  fixP->fx_addsy = NULL;
 		  fixP->fx_subsy = NULL;
 		  fixP->fx_done = 1;
@@ -4368,6 +4432,8 @@
 #ifdef DIFF_EXPR_OK
 	      else if (S_GET_SEGMENT (sub_symbolP) == this_segment_type)
 		{
+/* (TIGCC 20030716) Take TC_FORCE_RELOCATION_SUB_LOCAL into account. -- Kevin Kofler  */
+		 if (!TC_FORCE_RELOCATION_SUB_LOCAL (fixP)) {
 		  /* Make it pc-relative.  */
 		  add_number += (md_pcrel_from (fixP)
 				 - S_GET_VALUE (sub_symbolP));
@@ -4375,15 +4441,19 @@
 		  fixP->fx_pcrel = 1;
 		  sub_symbolP = 0;
 		  fixP->fx_subsy = 0;
+		 }
 		}
 #endif
 	      else
 		{
+/* (TIGCC 20030716) Take UNDEFINED_DIFFERENCE_OK into account. -- Kevin Kofler  */
+#ifndef UNDEFINED_DIFFERENCE_OK
 		  as_bad_where (fixP->fx_file, fixP->fx_line,
 				_("Can't emit reloc {- %s-seg symbol \"%s\"} @ file address %ld."),
 				segment_name (S_GET_SEGMENT (sub_symbolP)),
 				S_GET_NAME (sub_symbolP),
 				(long) (fragP->fr_address + where));
+#endif
 		}
 	    }
 	}
@@ -4522,7 +4592,13 @@
 
       md_apply_fix3 (fixP, (valueT *) & add_number, this_segment_type);
 
-      if (!fixP->fx_bit_fixP && ! fixP->fx_no_overflow)
+/* (TIGCC 20030716) Reuse fx_im_disp to turn off range checking on the 68k.
+                    -- Kevin Kofler  */
+      if (!fixP->fx_bit_fixP && ! fixP->fx_no_overflow
+#ifdef TC_M68K
+          && !fixP->fx_im_disp
+#endif
+      )
 	{
 #ifndef TC_M88K
 	  /* The m88k uses the offset field of the reloc to get around
diff -Naur binutils-2.16.1.orig/gas/config/obj-coff.h binutils-2.16.1-src/gas/config/obj-coff.h
--- binutils-2.16.1.orig/gas/config/obj-coff.h	Thu Mar  3 11:47:48 2005
+++ binutils-2.16.1-src/gas/config/obj-coff.h	Thu Jun 30 23:40:16 2005
@@ -487,7 +487,8 @@
 #define C_DEBUG_SECTION		N_DEBUG
 #define C_NTV_SECTION		N_TV
 #define C_PTV_SECTION		P_TV
-#define C_REGISTER_SECTION	50
+/* (TIGCC 20040905) Don't hardcode number of sections here. -- Kevin Kofler */
+#define C_REGISTER_SECTION	(N_SEGMENTS+10)
 
 /* Macros to extract information from a symbol table entry.
    This syntactic indirection allows independence regarding a.out or coff.
@@ -510,20 +511,31 @@
 /* Return true for symbols that should not be reduced to section
    symbols or eliminated from expressions, because they may be
    overridden by the linker.  */
+/* (TIGCC 20030716) Never reduce or eliminate relocs in all-relocs mode.
+   (TIGCC 20040719) Don't force relocs for absolute symbols if !flag_all_relocs.
+   (TIGCC 20040725) Force relocs for symbols in mergeable sections.
+                    -- Kevin Kofler  */
 #define S_FORCE_RELOC(s, strict) \
-  (!SEG_NORMAL (S_GET_SEGMENT (s)) || (strict && S_IS_WEAK (s)))
+  ((!SEG_NORMAL (S_GET_SEGMENT (s)) && S_GET_SEGMENT (s) != absolute_section) \
+   || (strict && S_IS_WEAK (s)) || flag_all_relocs \
+   || (segment_info[S_GET_SEGMENT (s)].scnhdr.s_flags & STYP_MERGEABLE))
 
 /* True if a debug special symbol entry.  */
 #define S_IS_DEBUG(s) \
   ((s)->sy_symbol.ost_entry.n_scnum == C_DEBUG_SECTION)
 
 /* True if a symbol is local symbol name.  */
-/* A symbol name whose name includes ^A is a gas internal pseudo symbol.  */
+/* A symbol name whose name includes ^A is a gas internal pseudo symbol.
+   (TIGCC 20030716) However, we want them output when outputting local symbols.
+   (TIGCC 20040724) Also, we always want to output local symbols in mergeable
+                    sections, because our linker relies on that.
+                    -- Kevin Kofler  */
 #define S_IS_LOCAL(s) \
   ((s)->sy_symbol.ost_entry.n_scnum == C_REGISTER_SECTION \
-   || (S_LOCAL_NAME(s) && ! flag_keep_locals && ! S_IS_DEBUG (s)) \
-   || strchr (S_GET_NAME (s), '\001') != NULL \
-   || strchr (S_GET_NAME (s), '\002') != NULL \
+   || (S_LOCAL_NAME(s) && ! flag_keep_locals && ! S_IS_DEBUG (s) \
+       && !(segment_info[S_GET_SEGMENT (s)].scnhdr.s_flags & STYP_MERGEABLE)) \
+   || (strchr (S_GET_NAME (s), '\001') != NULL && ! flag_keep_locals) \
+   || (strchr (S_GET_NAME (s), '\002') != NULL && ! flag_keep_locals) \
    || (flag_strip_local_absolute \
        && !S_IS_EXTERNAL(s) \
        && (s)->sy_symbol.ost_entry.n_scnum == C_ABS_SECTION))
diff -Naur binutils-2.16.1.orig/gas/config/tc-m68k.c binutils-2.16.1-src/gas/config/tc-m68k.c
--- binutils-2.16.1.orig/gas/config/tc-m68k.c	Tue Mar 22 15:31:48 2005
+++ binutils-2.16.1-src/gas/config/tc-m68k.c	Thu Jun 30 23:40:16 2005
@@ -79,6 +79,7 @@
 int flag_want_pic;
 
 static int flag_short_refs;	/* -l option.  */
+static int flag_short_jumps;	/* --short-jumps option */
 static int flag_long_jumps;	/* -S option.  */
 static int flag_keep_pcrel;	/* --pcrel option.  */
 
@@ -579,6 +580,10 @@
   {"extend", float_cons, 'x'},
   {"ldouble", float_cons, 'x'},
 
+  /* Dwarf2 support for Gcc.  */
+  {"file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0},
+  {"loc", dwarf2_directive_loc, 0},
+
   /* The following pseudo-ops are supported for MRI compatibility.  */
   {"chip", s_chip, 0},
   {"comline", s_space, 1},
@@ -777,15 +782,24 @@
 short
 tc_coff_fix2rtype (fixS *fixP)
 {
+/* (TIGCC 20040920) Handle unoptimizable relocs.  -- Kevin Kofler */
+  short isunopt;
+  isunopt = (fixP->fx_unoptimizable) ? R_UNOPTIMIZABLE : 0;
+
   if (fixP->fx_tcbit && fixP->fx_size == 4)
-    return R_RELLONG_NEG;
+    return isunopt | R_RELLONG_NEG;
+/* (TIGCC 20030716) Handle word and byte negative relocs.  -- Kevin Kofler */
+  if (fixP->fx_tcbit && fixP->fx_size == 2)
+    return isunopt | R_RELWORD_NEG;
+  if (fixP->fx_tcbit && fixP->fx_size == 1)
+    return isunopt | R_RELBYTE_NEG;
 #ifdef NO_PCREL_RELOCS
   know (fixP->fx_pcrel == 0);
-  return (fixP->fx_size == 1 ? R_RELBYTE
+  return isunopt | (fixP->fx_size == 1 ? R_RELBYTE
 	  : fixP->fx_size == 2 ? R_DIR16
 	  : R_DIR32);
 #else
-  return (fixP->fx_pcrel
+  return isunopt | (fixP->fx_pcrel
 	  ? (fixP->fx_size == 1 ? R_PCRBYTE
 	     : fixP->fx_size == 2 ? R_PCRWORD
 	     : R_PCRLONG)
@@ -2759,6 +2773,7 @@
 	      add_fix ('B', &opP->disp, 1, -1);
 	      break;
 	    case 'W':
+	    word_branch: /* (TIGCC 20050130) */
 	      add_fix ('w', &opP->disp, 1, 0);
 	      addword (0);
 	      break;
@@ -2771,6 +2786,20 @@
 	      addword (0);
 	      addword (0);
 	      break;
+	    case 'G': /* (TIGCC 20050130) */
+	    /* (TIGCC 20050130) We want only branches (word). -- Kevin Kofler */
+	      if (subs (&opP->disp))	/* We can't relax it.  */
+		goto word_branch;
+
+#ifdef OBJ_ELF
+	      /* If the displacement needs pic relocation it cannot be
+		 relaxed.  */
+	      if (opP->disp.pic_reloc != pic_none)
+		goto word_branch;
+#endif
+	      add_frag (adds (&opP->disp), offs (&opP->disp),
+			TAB (BRANCHBW, SZ_UNDEF));
+	      break;
 	    case 'g':
 	      if (subs (&opP->disp))	/* We can't relax it.  */
 		goto long_branch;
@@ -2793,8 +2822,15 @@
 		    the_ins.opcode[0] = 0x4EB9;
 		  else					/* jCC */
 		    {
+		      /* (TIGCC 20030902) Add a PC-relative reloc (unconditionally, because
+		                          it will be removed later on if not in all-relocs
+		                          mode). -- Kevin Kofler  */
+		      struct m68k_exp temp_expr = {SIZE_UNSPEC,
+		      {symbol_new (FAKE_LABEL_NAME, now_seg, (valueT) frag_now_fix () + 8, frag_now),
+		      NULL, 0, O_symbol, 0, 0}};
 		      the_ins.opcode[0] ^= 0x0100;
 		      the_ins.opcode[0] |= 0x0006;
+		      add_fix ('B' /*case-sensitive!*/, &temp_expr, 1 /*PCREL*/, -1 /*PCREL fix for bytes*/);
 		      addword (0x4EF9);
 		    }
 		  add_fix ('l', &opP->disp, 0, 0);
@@ -3955,7 +3991,7 @@
       current_label = NULL;
     }
 
-#ifdef OBJ_ELF
+#if 1 /*def OBJ_ELF*/
   /* Tie dwarf2 debug info to the address at the start of the insn.  */
   dwarf2_emit_insn (0);
 #endif
@@ -4008,6 +4044,13 @@
 	  fixP->fx_pcrel_adjust = the_ins.reloc[m].pcrel_fix;
 	  if (the_ins.reloc[m].wid == 'B')
 	    fixP->fx_signed = 1;
+	  /* (TIGCC 20050130) These relocs are by definition the ones which cannot
+	                      be "relaxed" - or "optimized" in ld-tigcc terms.
+	                      Excepted from this are byte branches because the
+	                      linker must be able to remove them entirely.
+	                      -- Kevin Kofler */
+	  else
+	    fixP->fx_unoptimizable = 1;
 	}
       return;
     }
@@ -4068,6 +4111,10 @@
 			      get_reloc_code (wid, the_ins.reloc[m].pcrel,
 					      the_ins.reloc[m].pic_reloc));
 	  fixP->fx_pcrel_adjust = the_ins.reloc[m].pcrel_fix;
+	  /* (TIGCC 20050130) These relocs are by definition the ones which cannot
+	                      be "relaxed" - or "optimized" in ld-tigcc terms.
+	                      -- Kevin Kofler */
+	  fixP->fx_unoptimizable = 1;
 	}
       (void) frag_var (rs_machine_dependent, 10, 0,
 		       (relax_substateT) (the_ins.fragb[n].fragty),
@@ -4105,6 +4152,10 @@
 			  get_reloc_code (wid, the_ins.reloc[m].pcrel,
 					  the_ins.reloc[m].pic_reloc));
       fixP->fx_pcrel_adjust = the_ins.reloc[m].pcrel_fix;
+      /* (TIGCC 20050130) These relocs are by definition the ones which cannot
+                          be "relaxed" - or "optimized" in ld-tigcc terms.
+                          -- Kevin Kofler */
+      fixP->fx_unoptimizable = 1;
     }
 }
 
@@ -4126,6 +4177,8 @@
     return ret;
   if (op1 < op2)
     return -1;
+  if (op1 > op2)
+    return 1; /* (TIGCC 200505611) This is required for Windows. -- Kevin Kofler */
   return 0;
 }
 
@@ -4619,7 +4672,9 @@
 
   val = SEXT (val);
 
-  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
+/* (TIGCC 20030716) We aren't done when we still have something to subtract.
+                    -- Kevin Kofler  */
+  if (fixP->fx_addsy == NULL && fixP->fx_subsy == NULL && fixP->fx_pcrel == 0)
     fixP->fx_done = 1;
 
 #ifdef OBJ_ELF
@@ -4642,6 +4697,55 @@
     return;
 #endif
 
+  /* Fix up a negative reloc.  */
+  if (fixP->fx_addsy == NULL && fixP->fx_subsy != NULL)
+    {
+      fixP->fx_addsy = fixP->fx_subsy;
+      fixP->fx_subsy = NULL;
+      fixP->fx_tcbit = 1;
+      val = -val; /* (TIGCC 20030716) */
+    }
+  /* (TIGCC 20030716) Fix up an address difference by splitting it into its
+                      components.
+                      Fix up subtraction of the dot symbol by changing the reloc
+                      to PC-relative (disabled 20030717).  -- Kevin Kofler
+     (TIGCC 20040807) For common symbols, the value is the size, not the
+                      position, so don't use it.  -- Kevin Kofler  */
+  else if (fixP->fx_addsy != NULL && fixP->fx_subsy != NULL)
+    {
+#if 0 /* (TIGCC 20030717) This is unnecessary (see expr.c fix) and probably wrong. */
+      if (!~fixP->fx_subsy->sy_number) { /* detect the dot symbol */
+        /* make the reloc PC-relative: */
+        val += md_pcrel_from (fixP);
+        fixP->fx_offset = *valP = val;
+        fixP->fx_pcrel = 1;
+        fixP->fx_subsy = NULL;
+      } else {
+#endif
+        fixS *negreloc = fix_new (fixP->fx_frag, fixP->fx_where, fixP->fx_size,
+                                  fixP->fx_subsy, fixP->fx_offset
+                                                  + (S_IS_COMMON (fixP->fx_addsy) ? 0 : S_GET_VALUE (fixP->fx_addsy))
+                                                  + segment_info[S_GET_SEGMENT (fixP->fx_addsy)].scnhdr.s_paddr
+                                                  - (((S_IS_COMMON (fixP->fx_subsy) ? 0 : S_GET_VALUE (fixP->fx_subsy))
+                                                     + segment_info[S_GET_SEGMENT (fixP->fx_subsy)].scnhdr.s_paddr)
+                                                     << 1) /* (TIGCC 20030717) Yes, we need to subtract this twice!
+                                                               This kludge compensates for later incorrect
+                                                               computations in obj-coff.c. -- Kevin Kofler  */,
+                                  0, 0);
+        if (negreloc) {
+          fixP->fx_offset = 0; /* We have transferred the offset to the negative reloc.  */
+          fixP->fx_pcrel = 0;
+          fixP->fx_subsy = NULL;
+          negreloc->fx_tcbit = 1;
+          /* turn off range checking for both relocs: */
+          fixP->fx_im_disp = negreloc->fx_im_disp = 1;
+        }
+#if 0
+      }
+#endif
+    }
+
+  /* (TIGCC 20030716) Moved this down so val can be adjusted. -- Kevin Kofler  */
   switch (fixP->fx_size)
     {
       /* The cast to offsetT below are necessary to make code
@@ -4669,13 +4773,8 @@
       BAD_CASE (fixP->fx_size);
     }
 
-  /* Fix up a negative reloc.  */
-  if (fixP->fx_addsy == NULL && fixP->fx_subsy != NULL)
-    {
-      fixP->fx_addsy = fixP->fx_subsy;
-      fixP->fx_subsy = NULL;
-      fixP->fx_tcbit = 1;
-    }
+  /* (TIGCC 20030716) Reuse fx_im_disp to turn off range checking. -- Kevin Kofler  */
+  if (fixP->fx_im_disp) return;
 
   /* For non-pc-relative values, it's conceivable we might get something
      like "0xff" for a byte field.  So extend the upper part of the range
@@ -4684,7 +4783,17 @@
   if (! fixP->fx_pcrel && ! fixP->fx_signed)
     upper_limit = upper_limit * 2 + 1;
 
-  if ((addressT) val > upper_limit
+  /* (TIGCC 20050507) We can't properly range-check PC-relative relocs in
+     all-relocs mode because of COFF VMA annoyances. Ideally, the section
+     contents should be just unrelocated offsets which can be properly
+     range-checked, but unfortunately COFF is designed with unrelocated use in
+     mind and relocation as an afterthought. And moreover, we need to
+     range-check in the linker anyway, as only the linker knows the final
+     section disposition. So let's just let the linker worry about
+     range-checking. */
+  if (fixP->fx_pcrel)
+    fixP->fx_im_disp = 1;
+  else if ((addressT) val > upper_limit
       && (val > 0 || val < lower_limit))
     as_bad_where (fixP->fx_file, fixP->fx_line, _("value out of range"));
 
@@ -4795,6 +4904,27 @@
       fragP->fr_opcode[0] ^= 0x01;	/* Invert bcc.  */
       fragP->fr_opcode[1]  = 0x06;	/* Branch offset = 6.  */
 
+      /* (TIGCC 20030902) Add a PC-relative reloc (unconditionally, because
+                          it will be removed later on if not in all-relocs
+                          mode).  -- Kevin Kofler
+         (TIGCC 20030908) Unfortunately, we cannot create symbols here for some
+                          reason, so we create the symbol in advance in
+                          md_estimate_size_before_relax and store it into the
+                          frag structure of the next frag. Here, we only have to
+                          read it.  -- Kevin Kofler, patch by Sebastian Reichelt
+         */
+      {
+	fragS *nextFragP = fragP->fr_next;
+	symbolS *symbolP = NULL;
+	if (nextFragP)
+	  symbolP = nextFragP->fr_start_symbol;
+
+	if (symbolP)
+	  fix_new (fragP, fragP->fr_fix - 1, 1, symbolP, -1, 1, RELAX_RELOC_PC8);
+	else
+	  as_warn_where (fragP->fr_file, fragP->fr_line, _("no symbol available for pseudo-op code"));
+      }
+
       /* JF: these used to be fr_opcode[2,3], but they may be in a
 	   different frag, in which case referring to them is a no-no.
 	   Only fr_opcode[0,1] are guaranteed to work.  */
@@ -4963,8 +5093,17 @@
 	    && relaxable_symbol (fragP->fr_symbol))
 	  {
 	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), BYTE);
+	    /* (TIGCC 20030909) Create a symbol at the beginning of the next frag
+	                        and store it into the frag structure, because
+	                        md_convert_frag_1 might need a symbol there, but
+	                        can't create it itself. This is necessary only for
+	                        conditional jumps. -- Kevin Kofler  */
+	    if ((TABTYPE (fragP->fr_subtype) == BRABSJCOND) && fragP->fr_next)
+	      {
+		fragP->fr_next->fr_start_symbol = symbol_new (FAKE_LABEL_NAME, segment, fragP->fr_next->fr_address, fragP->fr_next);
+	      }
 	  }
-	else if (flag_short_refs)
+	else if (flag_short_jumps)
 	  {
 	    /* Symbol is undefined and we want short ref.  */
 	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
@@ -4973,6 +5112,17 @@
 	  {
 	    /* Symbol is still undefined.  Make it LONG.  */
 	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), LONG);
+	    /* (TIGCC 20030908) Create a symbol at the beginning of the next frag
+	                        and store it into the frag structure, because
+	                        md_convert_frag_1 might need a symbol there, but
+	                        can't create it itself.
+	                        -- Kevin Kofler, patch by Sebastian Reichelt
+	       (TIGCC 20030909) This is necessary only for conditional jumps.
+	                        -- Kevin Kofler  */
+	    if ((TABTYPE (fragP->fr_subtype) == BRABSJCOND) && fragP->fr_next)
+	      {
+		fragP->fr_next->fr_start_symbol = symbol_new (FAKE_LABEL_NAME, segment, fragP->fr_next->fr_address, fragP->fr_next);
+	      }
 	  }
 	break;
       }
@@ -4999,7 +5149,7 @@
       {
 	if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
 	     && relaxable_symbol (fragP->fr_symbol))
-	    || flag_short_refs)
+	    || flag_short_jumps)
 	  {
 	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
 	  }
@@ -5025,7 +5175,8 @@
     case TAB (ABSTOPCREL, SZ_UNDEF):
       {
 	if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
-	     && relaxable_symbol (fragP->fr_symbol)))
+	     && relaxable_symbol (fragP->fr_symbol))
+	    || flag_short_refs)
 	  {
 	    fragP->fr_subtype = TAB (ABSTOPCREL, SHORT);
 	  }
@@ -5069,6 +5220,7 @@
 	    }
 	}
       break;
+
     default:
       break;
     }
@@ -7067,6 +7219,8 @@
   {"disp-size-default-32", no_argument, NULL, OPTION_DISP_SIZE_DEFAULT_32},
 #define OPTION_PCREL (OPTION_MD_BASE + 7)
   {"pcrel", no_argument, NULL, OPTION_PCREL},
+#define OPTION_SHORT_JUMPS (OPTION_MD_BASE + 8)
+  {"short-jumps", no_argument, NULL, OPTION_SHORT_JUMPS},
   {NULL, no_argument, NULL, 0}
 };
 size_t md_longopts_size = sizeof (md_longopts);
@@ -7079,6 +7233,12 @@
     case 'l':			/* -l means keep external to 2 bit offset
 				   rather than 16 bit one.  */
       flag_short_refs = 1;
+      flag_short_jumps = 1;
+      break;
+
+    case OPTION_SHORT_JUMPS:	/* --short-jumps is like -l only for
+				   jumps.  */
+      flag_short_jumps = 1;
       break;
 
     case 'S':			/* -S means that jbsr's always turn into
@@ -7255,6 +7415,7 @@
   fprintf (stream, _("\
 680X0 options:\n\
 -l			use 1 word for refs to undefined symbols [default 2]\n\
+--short-jumps		use 1 word for jumps to undefined symbols [default 2]\n\
 -m68000 | -m68008 | -m68010 | -m68020 | -m68030 | -m68040 | -m68060 |\n\
 -m68302 | -m68331 | -m68332 | -m68333 | -m68340 | -m68360 | -mcpu32 |\n\
 -m5200  | -m5202  | -m5204  | -m5206  | -m5206e | -m521x  | -m5249  |\n\
diff -Naur binutils-2.16.1.orig/gas/config/tc-m68k.h binutils-2.16.1-src/gas/config/tc-m68k.h
--- binutils-2.16.1.orig/gas/config/tc-m68k.h	Tue Mar  1 22:35:20 2005
+++ binutils-2.16.1-src/gas/config/tc-m68k.h	Thu Jun 30 23:40:16 2005
@@ -234,3 +234,20 @@
 
 #define tc_cfi_frame_initial_instructions tc_m68k_frame_initial_instructions
 extern void tc_m68k_frame_initial_instructions (void);
+
+/* (TIGCC 20030716) Allow difference of undefined symbols. -- Kevin Kofler  */
+#define UNDEFINED_DIFFERENCE_OK
+
+/* (TIGCC 20030716) Force relocs in all-relocs mode. -- Kevin Kofler  */
+#define TC_FORCE_RELOCATION(FIX)		\
+  (generic_force_reloc (FIX))
+#define TC_FORCE_RELOCATION_ABS(FIX)		\
+  (0)
+#define TC_FORCE_RELOCATION_LOCAL(FIX)		\
+  (TC_FORCE_RELOCATION (FIX))
+#define TC_FORCE_RELOCATION_SUB_SAME(FIX, SEG)	\
+  (! SEG_NORMAL (SEG) || TC_FORCE_RELOCATION (FIX))
+#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX)	\
+  (TC_FORCE_RELOCATION (FIX))
+/* (END TIGCC 20030716) */
+
diff -Naur binutils-2.16.1.orig/gas/configure binutils-2.16.1-src/gas/configure
--- binutils-2.16.1.orig/gas/configure	Tue Mar  1 00:43:50 2005
+++ binutils-2.16.1-src/gas/configure	Thu Jun 30 23:40:16 2005
@@ -10839,7 +10839,7 @@
 
 
 
-                              ac_config_files="$ac_config_files Makefile doc/Makefile po/Makefile.in:po/Make-in"
+                              ac_config_files="$ac_config_files Makefile"
 
           ac_config_commands="$ac_config_commands default"
 
diff -Naur binutils-2.16.1.orig/gas/dwarf2dbg.c binutils-2.16.1-src/gas/dwarf2dbg.c
--- binutils-2.16.1.orig/gas/dwarf2dbg.c	Thu Mar  3 01:29:52 2005
+++ binutils-2.16.1-src/gas/dwarf2dbg.c	Thu Jun 30 23:40:16 2005
@@ -53,7 +53,15 @@
 # define DWARF2_ADDR_SIZE(bfd) (bfd_arch_bits_per_address (bfd) / 8)
 #endif
 
-#ifdef BFD_ASSEMBLER
+#ifndef BFD_ASSEMBLER
+# define section_symbol(SEC) seg_info(SEC)->dwarf2_secsym
+#endif
+
+#ifdef __MINGW32__
+# define ffs __builtin_ffs
+#endif
+
+#if 1 /*def BFD_ASSEMBLER*/
 
 #include "subsegs.h"
 
@@ -331,6 +339,13 @@
   dwarf2_gen_line_info (frag_now_fix () - size, &loc);
 }
 
+void
+dwarf2_emit_insn_if_loc_seen (int size)
+{
+  if (loc_directive_seen)
+    dwarf2_emit_insn (size);
+}
+
 /* Get a .debug_line file number for FILENAME.  If NUM is nonzero,
    allocate it on that file table slot, otherwise return the first
    empty one.  */
@@ -962,7 +977,9 @@
       if (1 /* line != e->loc.line || changed */)
 	{
 	  int line_delta = e->loc.line - line;
-	  if (frag == NULL)
+	  /* (TIGCC 20050415) Always use DW_LNE_set_address, as everything else is
+	     incompatible with linker optimization. -- Kevin Kofler */
+	  if (1 /*frag == NULL*/)
 	    {
 	      out_set_addr (seg, e->frag, e->frag_ofs);
 	      out_inc_line_addr (line_delta, 0);
@@ -992,11 +1009,16 @@
   /* Emit a DW_LNE_end_sequence for the end of the section.  */
   last_frag = last_frag_for_seg (seg);
   last_frag_ofs = get_frag_fix (last_frag);
+#if 0 /* (TIGCC 20050419) */
   if (frag == last_frag)
     out_inc_line_addr (INT_MAX, last_frag_ofs - frag_ofs);
   else
     relax_inc_line_addr (INT_MAX, seg, last_frag, last_frag_ofs,
 			 frag, frag_ofs);
+#else
+  out_set_addr (seg, last_frag, last_frag_ofs);
+  out_inc_line_addr (INT_MAX, 0);
+#endif
 }
 
 /* Emit the directory and file tables for .debug_line.  */
@@ -1057,6 +1079,7 @@
   subseg_set (line_seg, 0);
 
   line_start = symbol_temp_new_now ();
+  seg_info (line_seg)->dwarf2_secsym = line_start; /* (TIGCC 20050407) */
   prologue_end = symbol_temp_make ();
   line_end = symbol_temp_make ();
 
@@ -1212,15 +1235,19 @@
 {
   subseg_set (abbrev_seg, 0);
 
+  seg_info (abbrev_seg)->dwarf2_secsym = symbol_temp_new_now (); /* (TIGCC 20050407) */
+
   out_uleb128 (1);
   out_uleb128 (DW_TAG_compile_unit);
   out_byte (DW_CHILDREN_no);
   out_abbrev (DW_AT_stmt_list, DW_FORM_data4);
+#if 0 /* (TIGCC 20050407) */
   if (all_segs->next == NULL)
     {
       out_abbrev (DW_AT_low_pc, DW_FORM_addr);
       out_abbrev (DW_AT_high_pc, DW_FORM_addr);
     }
+#endif
   out_abbrev (DW_AT_name, DW_FORM_string);
   out_abbrev (DW_AT_comp_dir, DW_FORM_string);
   out_abbrev (DW_AT_producer, DW_FORM_string);
@@ -1249,6 +1276,7 @@
   subseg_set (info_seg, 0);
 
   info_start = symbol_temp_new_now ();
+  seg_info (info_seg)->dwarf2_secsym = info_start; /* (TIGCC 20050407) */
   info_end = symbol_temp_make ();
 
   /* Compilation Unit length.  */
@@ -1297,6 +1325,7 @@
   /* ??? sizeof_offset */
   TC_DWARF2_EMIT_OFFSET (section_symbol (line_seg), 4);
 
+#if 0 /* (TIGCC 20050407) */
   /* These two attributes may only be emitted if all of the code is
      contiguous.  Multiple sections are not that.  */
   if (all_segs->next == NULL)
@@ -1313,6 +1342,7 @@
       expr.X_add_number = 0;
       emit_expr (&expr, sizeof_address);
     }
+#endif
 
   /* DW_AT_name.  We don't have the actual file name that was present
      on the command line, so assume files[1] is the main input file.
@@ -1366,8 +1396,37 @@
   segT info_seg;
   int emit_other_sections = 0;
 
+#ifdef BFD_ASSEMBLER
   info_seg = bfd_get_section_by_name (stdoutput, ".debug_info");
   emit_other_sections = info_seg == NULL || !seg_not_empty_p (info_seg);
+#else
+/* (TIGCC 20050403) Yes, this is ugly, it is mostly copied out of subseg_new and
+                    should be in its own function. -- Kevin Kofler */
+  int i;
+  info_seg = (segT)(-1);
+  for (i = 0; i < (int) SEG_MAXIMUM_ORDINAL; i++)
+    {
+      const char *s;
+
+      s = segment_name ((segT) i);
+      if (strcmp (".debug_info", s) == 0
+          || (strcmp ("debug_info", s) == 0))
+        {
+          info_seg = (segT) i;
+          break;
+        }
+#ifdef obj_segment_name
+      s = obj_segment_name ((segT) i);
+      if (strcmp (".debug_info", s) == 0
+          || (strcmp ("debug_info", s) == 0))
+        {
+          info_seg = (segT) i;
+          break;
+        }
+#endif
+    }
+  emit_other_sections = info_seg == (segT)(-1) || !seg_not_empty_p (info_seg);
+#endif
 
   if (!all_segs && emit_other_sections)
     /* There is no line information and no non-empty .debug_info
@@ -1375,11 +1434,17 @@
     return;
 
   /* Calculate the size of an address for the target machine.  */
+#ifdef BFD_ASSEMBLER
   sizeof_address = DWARF2_ADDR_SIZE (stdoutput);
+#else
+  sizeof_address = 4;
+#endif
 
   /* Create and switch to the line number section.  */
   line_seg = subseg_new (".debug_line", 0);
+#ifdef BFD_ASSEMBLER
   bfd_set_section_flags (stdoutput, line_seg, SEC_READONLY | SEC_DEBUGGING);
+#endif
 
   /* For each subsection, chain the debug entries together.  */
   for (s = all_segs; s; s = s->next)
@@ -1410,12 +1475,14 @@
       abbrev_seg = subseg_new (".debug_abbrev", 0);
       aranges_seg = subseg_new (".debug_aranges", 0);
 
+#ifdef BFD_ASSEMBLER
       bfd_set_section_flags (stdoutput, info_seg,
 			     SEC_READONLY | SEC_DEBUGGING);
       bfd_set_section_flags (stdoutput, abbrev_seg,
 			     SEC_READONLY | SEC_DEBUGGING);
       bfd_set_section_flags (stdoutput, aranges_seg,
 			     SEC_READONLY | SEC_DEBUGGING);
+#endif
 
       record_alignment (aranges_seg, ffs (2 * sizeof_address) - 1);
 
diff -Naur binutils-2.16.1.orig/gas/dwarf2dbg.h binutils-2.16.1-src/gas/dwarf2dbg.h
--- binutils-2.16.1.orig/gas/dwarf2dbg.h	Thu Mar  3 01:29:52 2005
+++ binutils-2.16.1-src/gas/dwarf2dbg.h	Thu Jun 30 23:40:16 2005
@@ -61,6 +61,7 @@
 
 /* Must be called for each generated instruction.  */
 extern void dwarf2_emit_insn (int);
+extern void dwarf2_emit_insn_if_loc_seen (int);
 
 extern void dwarf2_finish (void);
 
diff -Naur binutils-2.16.1.orig/gas/expr.c binutils-2.16.1-src/gas/expr.c
--- binutils-2.16.1.orig/gas/expr.c	Thu Mar  3 17:22:12 2005
+++ binutils-2.16.1-src/gas/expr.c	Thu Jun 30 23:40:16 2005
@@ -1751,8 +1751,11 @@
 	  /* X + constant.  */
 	  resultP->X_add_number += right.X_add_number;
 	}
-      /* This case comes up in PIC code.  */
-      else if (op_left == O_subtract
+      /* This case comes up in PIC code.
+         (TIGCC 20040719) This optimization isn't valid in all-relocs mode.
+                          -- Kevin Kofler  */
+      else if (!flag_all_relocs
+	       && op_left == O_subtract
 	       && right.X_op == O_symbol
 	       && resultP->X_op == O_symbol
 	       && (symbol_get_frag (right.X_add_symbol)
@@ -1848,6 +1851,15 @@
 		       && right.X_add_number == 0)))
 	{
 	  /* Symbol OP symbol.  */
+
+	  /* (TIGCC 20030717) Optimize .set sym2,sym3+c; sym1-sym2 to
+	     .set sym2,sym3+c; sym1-(sym3+c). The code below will further change
+	     this to .set sym2,sym3+c; (sym1-c)-sym3. -- Kevin Kofler  */
+	  if (!right.X_add_number && right.X_add_symbol->sy_value.X_op == O_symbol) {
+	    resolve_symbol_value(right.X_add_symbol);
+	    memcpy(&right, &right.X_add_symbol->sy_value, sizeof(expressionS));
+	  }
+
 	  resultP->X_op = op_left;
 	  resultP->X_op_symbol = right.X_add_symbol;
 	  if (op_left == O_add)
diff -Naur binutils-2.16.1.orig/gas/frags.h binutils-2.16.1-src/gas/frags.h
--- binutils-2.16.1.orig/gas/frags.h	Thu Mar  3 01:29:52 2005
+++ binutils-2.16.1-src/gas/frags.h	Thu Jun 30 23:40:16 2005
@@ -66,6 +66,9 @@
   char *fr_file;
   unsigned int fr_line;
 
+  /* (TIGCC) Symbol at the beginning of the frag. May be NULL.  */
+  symbolS *fr_start_symbol;
+
 #ifndef NO_LISTING
   struct list_info_struct *line;
 #endif
diff -Naur binutils-2.16.1.orig/gas/listing.c binutils-2.16.1-src/gas/listing.c
--- binutils-2.16.1.orig/gas/listing.c	Thu Mar  3 01:29:52 2005
+++ binutils-2.16.1-src/gas/listing.c	Thu Jun 30 23:40:16 2005
@@ -944,7 +944,8 @@
   int show_listing = 1;
   unsigned int width;
 
-  buffer = xmalloc (listing_rhs_width);
+  buffer = xmalloc (listing_rhs_width + 1); /* (TIGCC 20030901) Add 1 for the
+    terminating '\0' character. -- Kevin Kofler  */
   data_buffer = xmalloc (MAX_BYTES);
   eject = 1;
   list = head;
@@ -962,8 +963,8 @@
     {
       unsigned int list_line;
 
-      width = listing_rhs_width > paper_width ? paper_width :
-	listing_rhs_width;
+      width = (listing_rhs_width > paper_width ? paper_width :
+	listing_rhs_width) + 1; /* (TIGCC 20030901) See above.  */
 
       list_line = list->line;
       switch (list->edict)
diff -Naur binutils-2.16.1.orig/gas/read.c binutils-2.16.1-src/gas/read.c
--- binutils-2.16.1.orig/gas/read.c	Wed Apr 13 19:58:40 2005
+++ binutils-2.16.1-src/gas/read.c	Thu Jun 30 23:40:16 2005
@@ -40,6 +40,7 @@
 #include "obstack.h"
 #include "listing.h"
 #include "ecoff.h"
+#include "dwarf2dbg.h"
 #include "dw2gencfi.h"
 
 #ifndef TC_START_LABEL
@@ -3273,6 +3274,14 @@
 	{
 	  symbolS *s = exp.X_add_symbol;
 
+	  /* (TIGCC 20050611) Don't evaluate defined+const here, as this breaks
+	                      all-relocs mode. -- Kevin Kofler */
+	  if (exp.X_add_number != 0)
+	    {
+	      symbol_set_value_expression (symbolP, &exp);
+	      break;
+	    }
+
 	  S_SET_SEGMENT (symbolP, seg);
 	  S_SET_VALUE (symbolP, exp.X_add_number + S_GET_VALUE (s));
 	  symbol_set_frag (symbolP, symbol_get_frag (s));
@@ -3427,7 +3436,13 @@
 void
 cons (int size)
 {
+  /* (TIGCC 20050603) Call dwarf2_emit_insn_if_loc_seen unless we are in a
+                      debugging info section. -- Kevin Kofler */
+  const char *segname;
   cons_worker (size, 0);
+  segname = seg_info (now_seg)->scnhdr.s_name;
+  if (strncmp (segname, ".debug_", 7) && strncmp (segname, ".eh_", 4))
+    dwarf2_emit_insn_if_loc_seen (size);
 }
 
 void
@@ -3768,8 +3783,9 @@
 #define TC_CONS_RELOC 0
 #endif
 #endif
+      /* (TIGCC 20040920) Constants aren't optimizable relocs. -- Kevin Kofler */
       fix_new_exp (frag_now, p - frag_now->fr_literal, (int) nbytes, exp, 0,
-		   TC_CONS_RELOC);
+		   TC_CONS_RELOC) -> fx_unoptimizable = 1;
 #endif /* TC_CONS_FIX_NEW */
 #endif /* BFD_ASSEMBLER */
     }
diff -Naur binutils-2.16.1.orig/gas/subsegs.c binutils-2.16.1-src/gas/subsegs.c
--- binutils-2.16.1.orig/gas/subsegs.c	Thu Mar  3 11:47:44 2005
+++ binutils-2.16.1-src/gas/subsegs.c	Thu Jun 30 23:40:16 2005
@@ -41,6 +41,8 @@
 
 #endif /* MANY_SEGMENTS */
 char const *const seg_name[] = {
+/* (TIGCC 20040905) Allow arbitrary number of sections here. -- Kevin Kofler */
+#if 0
   "absolute",
 #ifdef MANY_SEGMENTS
   "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9",
@@ -52,6 +54,7 @@
   "data",
   "bss",
 #endif /* MANY_SEGMENTS */
+#endif /* 0 */
   "unknown",
   "ASSEMBLER-INTERNAL-LOGIC-ERROR!",
   "expr",
@@ -61,6 +64,17 @@
   "register",
   "",
 };				/* Used by error reporters, dumpers etc.  */
+
+char *segment_name (n) int n;
+{
+  if (!n) return "absolute";
+  else if (SEG_NORMAL(n)) {
+    static char s[8];
+    sprintf(s,"e%d",n-SEG_E0);
+    return s;
+  } else return seg_name[n-(N_SEGMENTS+1)];
+}
+
 #else /* BFD_ASSEMBLER */
 
 /* Gas segment information for bfd_abs_section_ptr and
diff -Naur binutils-2.16.1.orig/gas/subsegs.h binutils-2.16.1-src/gas/subsegs.h
--- binutils-2.16.1.orig/gas/subsegs.h	Thu Feb 17 13:46:00 2005
+++ binutils-2.16.1-src/gas/subsegs.h	Thu Jun 30 23:40:16 2005
@@ -89,6 +89,7 @@
 #endif
 
   symbolS *dot;
+  symbolS *dwarf2_secsym; /* (TIGCC 20050407) */
 
   struct lineno_list *lineno_list_head;
   struct lineno_list *lineno_list_tail;
diff -Naur binutils-2.16.1.orig/gas/symbols.c binutils-2.16.1-src/gas/symbols.c
--- binutils-2.16.1.orig/gas/symbols.c	Wed Apr 13 19:58:40 2005
+++ binutils-2.16.1-src/gas/symbols.c	Thu Jun 30 23:40:16 2005
@@ -1143,6 +1143,14 @@
 		       || add_symbol == op_symbol)))
 	    report_op_error (symp, add_symbol, op_symbol);
 
+	  /* (TIGCC 20040719) In all-relocs mode, we can't apply operations other
+	                      than + or - on an address or address difference.
+	                      -- Kevin Kofler */
+	  if (flag_all_relocs && finalize_syms
+	      && !(op == O_subtract || op == O_add)
+	      && final_seg == undefined_section)
+	    report_op_error (symp, add_symbol, op_symbol);
+
 	  if (final_seg == expr_section || final_seg == undefined_section)
 	    final_seg = absolute_section;
 
diff -Naur binutils-2.16.1.orig/gas/symbols.h binutils-2.16.1-src/gas/symbols.h
--- binutils-2.16.1.orig/gas/symbols.h	Wed Apr 13 19:58:40 2005
+++ binutils-2.16.1-src/gas/symbols.h	Thu Jun 30 23:40:16 2005
@@ -144,11 +144,16 @@
 /*
  * Current means for getting from symbols to segments and vice verse.
  * This will change for infinite-segments support (e.g. COFF).
+ * (TIGCC 20040905) And indeed it does. -- Kevin Kofler
  */
 extern const segT N_TYPE_seg[];	/* subseg.c */
 
+#if 0
 #define	SEGMENT_TO_SYMBOL_TYPE(seg)  ( seg_N_TYPE [(int) (seg)] )
 extern const short seg_N_TYPE[];/* subseg.c */
+#else
+short SEGMENT_TO_SYMBOL_TYPE PARAMS ((int seg));
+#endif
 
 #define	N_REGISTER	30	/* Fake N_TYPE value for SEG_REGISTER */
 
diff -Naur binutils-2.16.1.orig/gas/write.c binutils-2.16.1-src/gas/write.c
--- binutils-2.16.1.orig/gas/write.c	Thu Mar  3 01:29:52 2005
+++ binutils-2.16.1-src/gas/write.c	Thu Jun 30 23:40:16 2005
@@ -217,6 +217,7 @@
 #if defined(NEED_FX_R_TYPE) || defined (BFD_ASSEMBLER)
   fixP->fx_r_type = r_type;
 #endif
+  fixP->fx_unoptimizable = 0; /* (TIGCC 20040920) */
   fixP->fx_im_disp = 0;
   fixP->fx_pcrel_adjust = 0;
   fixP->fx_bit_fixP = 0;
@@ -831,6 +832,11 @@
 	    continue;
 	  }
 
+	/* (TIGCC 20030716) Only reduce relocs which refer to local symbols we
+	                    aren't going to output. -- Kevin Kofler  */
+	if (! S_IS_LOCAL (sym))
+		continue;
+
 	/* Don't try to reduce relocs which refer to non-local symbols
            in .linkonce sections.  It can lead to confusion when a
            debugging section refers to a .linkonce section.  I hope
@@ -1381,7 +1387,7 @@
       /* This now gets called even if we had errors.  In that case,
          any alignment is meaningless, and, moreover, will look weird
          if we are generating a listing.  */
-      if (!had_errors ())
+      if (0 /*!had_errors ()*/)
 	{
 	  alignment = SUB_SEGMENT_ALIGN (now_seg, frchainP);
 #ifdef BFD_ASSEMBLER
diff -Naur binutils-2.16.1.orig/gas/write.h binutils-2.16.1-src/gas/write.h
--- binutils-2.16.1.orig/gas/write.h	Thu Mar  3 01:29:52 2005
+++ binutils-2.16.1-src/gas/write.h	Thu Jun 30 23:40:16 2005
@@ -71,9 +71,12 @@
      look into it for version 2.6.  */
   unsigned fx_plt : 1;
 
+  /* (TIGCC 20040920) Is this an unoptimizable reloc? -- Kevin Kofler  */
+  unsigned fx_unoptimizable : 1;
+
   /* Is this value an immediate displacement?  */
   /* Only used on i960 and ns32k; merge it into TC_FIX_TYPE sometime.  */
-  unsigned fx_im_disp : 2;
+  unsigned fx_im_disp : 1;
 
   /* A bit for the CPU specific code.
      This probably can be folded into tc_fix_data, below.  */
diff -Naur binutils-2.16.1.orig/include/coff/internal.h binutils-2.16.1-src/include/coff/internal.h
--- binutils-2.16.1.orig/include/coff/internal.h	Thu Mar  3 11:58:04 2005
+++ binutils-2.16.1-src/include/coff/internal.h	Thu Jun 30 23:40:16 2005
@@ -350,6 +350,9 @@
 
 #define STYP_LIT	0x8020	/* Literal data (like STYP_TEXT) */
 
+/* (TIGCC 20040724) TIGCC COFF extensions for section flags -- Kevin Kofler */
+#define STYP_MERGEABLE 0x1000000
+#define STYP_UNALIGNED 0x2000000
 
 /********************** LINE NUMBERS **********************/
 
@@ -743,5 +746,10 @@
 #define R_W65_PCR16	9
 
 #define R_W65_DP       10  /* direct page 8 bits only   */
+
+/* (TIGCC 20030716, 20040920) TIGCC COFF extensions -- Kevin Kofler  */
+#define R_RELWORD_NEG 0x7161
+#define R_RELBYTE_NEG 0x7162
+#define R_UNOPTIMIZABLE 0x8000
 
 #endif /* GNU_COFF_INTERNAL_H */
diff -Naur binutils-2.16.1.orig/opcodes/configure binutils-2.16.1-src/opcodes/configure
--- binutils-2.16.1.orig/opcodes/configure	Mon Jan 31 20:30:36 2005
+++ binutils-2.16.1-src/opcodes/configure	Thu Jun 30 23:40:16 2005
@@ -271,7 +271,7 @@
 PACKAGE_STRING=
 PACKAGE_BUGREPORT=
 
-ac_unique_file="z8k-dis.c"
+ac_unique_file="m68k-dis.c"
 # Factoring default headers for most tests.
 ac_includes_default="\
 #include <stdio.h>
diff -Naur binutils-2.16.1.orig/opcodes/configure.in binutils-2.16.1-src/opcodes/configure.in
--- binutils-2.16.1.orig/opcodes/configure.in	Mon Nov  8 13:17:36 2004
+++ binutils-2.16.1-src/opcodes/configure.in	Thu Jun 30 23:40:16 2005
@@ -3,7 +3,7 @@
 
 AC_PREREQ(2.59)
 AC_INIT
-AC_CONFIG_SRCDIR([z8k-dis.c])
+AC_CONFIG_SRCDIR([m68k-dis.c])
 
 AC_CANONICAL_TARGET
 AC_ISC_POSIX
diff -Naur binutils-2.16.1.orig/opcodes/m68k-opc.c binutils-2.16.1-src/opcodes/m68k-opc.c
--- binutils-2.16.1.orig/opcodes/m68k-opc.c	Mon May 24 16:33:22 2004
+++ binutils-2.16.1-src/opcodes/m68k-opc.c	Thu Jun 30 23:40:16 2005
@@ -116,6 +116,22 @@
 {"asrl", 2,	one(0160200),	one(0170770), "QdDs", m68000up | mcfisa_a },
 {"asrl", 2,	one(0160240),	one(0170770), "DdDs", m68000up | mcfisa_a },
 
+/* (TIGCC 20050130) New branch type: variable-size, word by default. */
+{"bhi",	2, one(0061000),	one(0177777), "BG", m68000up | mcfisa_a },
+{"bls",	2, one(0061400),	one(0177777), "BG", m68000up | mcfisa_a },
+{"bcc",	2, one(0062000),	one(0177777), "BG", m68000up | mcfisa_a },
+{"bcs",	2, one(0062400),	one(0177777), "BG", m68000up | mcfisa_a },
+{"bne",	2, one(0063000),	one(0177777), "BG", m68000up | mcfisa_a },
+{"beq",	2, one(0063400),	one(0177777), "BG", m68000up | mcfisa_a },
+{"bvc",	2, one(0064000),	one(0177777), "BG", m68000up | mcfisa_a },
+{"bvs",	2, one(0064400),	one(0177777), "BG", m68000up | mcfisa_a },
+{"bpl",	2, one(0065000),	one(0177777), "BG", m68000up | mcfisa_a },
+{"bmi",	2, one(0065400),	one(0177777), "BG", m68000up | mcfisa_a },
+{"bge",	2, one(0066000),	one(0177777), "BG", m68000up | mcfisa_a },
+{"blt",	2, one(0066400),	one(0177777), "BG", m68000up | mcfisa_a },
+{"bgt",	2, one(0067000),	one(0177777), "BG", m68000up | mcfisa_a },
+{"ble",	2, one(0067400),	one(0177777), "BG", m68000up | mcfisa_a },
+
 {"bhiw", 2,	one(0061000),	one(0177777), "BW", m68000up | mcfisa_a },
 {"blsw", 2,	one(0061400),	one(0177777), "BW", m68000up | mcfisa_a },
 {"bccw", 2,	one(0062000),	one(0177777), "BW", m68000up | mcfisa_a },
@@ -199,6 +215,8 @@
 
 {"bkpt", 2,	one(0044110),	one(0177770), "ts", m68010up },
 
+/* (TIGCC 20050130) New branch type: variable-size, word by default. */
+{"bra",	2, one(0060000),	one(0177777), "BG", m68000up | mcfisa_a },
 {"braw", 2,	one(0060000),	one(0177777), "BW", m68000up | mcfisa_a },
 {"bral", 2,	one(0060377),	one(0177777), "BL", m68020up | cpu32 | mcfisa_b},
 {"bras", 2,	one(0060000),	one(0177400), "BB", m68000up | mcfisa_a },
@@ -208,6 +226,8 @@
 {"bset", 4,	one(0004300),	one(0177700), "#b$s", m68000up },
 {"bset", 4,	one(0004300),	one(0177700), "#bqs", mcfisa_a },
 
+/* (TIGCC 20050130) New branch type: variable-size, word by default. */
+{"bsr",	2, one(0060400),	one(0177777), "BG", m68000up | mcfisa_a },
 {"bsrw", 2,	one(0060400),	one(0177777), "BW", m68000up | mcfisa_a },
 {"bsrl", 2,	one(0060777),	one(0177777), "BL", m68020up | cpu32 | mcfisa_b},
 {"bsrs", 2,	one(0060400),	one(0177400), "BB", m68000up | mcfisa_a },
@@ -254,6 +274,7 @@
 
 {"clrb", 2,	one(0041000),	one(0177700), "$s", m68000up | mcfisa_a },
 {"clrw", 2,	one(0041100),	one(0177700), "$s", m68000up | mcfisa_a },
+{"clrl", 2,	one(0070000),	one(0170477), "Dd", m68000 },
 {"clrl", 2,	one(0041200),	one(0177700), "$s", m68000up | mcfisa_a },
 
 {"cmp2b", 4,	two(0000300,0), two(0177700,07777), "!sR1", m68020up | cpu32 },
@@ -263,11 +284,11 @@
 {"cmpaw", 2,	one(0130300),	one(0170700), "*wAd", m68000up },
 {"cmpal", 2,	one(0130700),	one(0170700), "*lAd", m68000up | mcfisa_a },
 
-{"cmpib", 4,	one(0006000),	one(0177700), "#b@s", m68000up },
+{"cmpib", 4,	one(0006000),	one(0177700), "#b$s", m68000up },
 {"cmpib", 4,	one(0006000),	one(0177700), "#bDs", mcfisa_b },
-{"cmpiw", 4,	one(0006100),	one(0177700), "#w@s", m68000up },
+{"cmpiw", 4,	one(0006100),	one(0177700), "#w$s", m68000up },
 {"cmpiw", 4,	one(0006100),	one(0177700), "#wDs", mcfisa_b },
-{"cmpil", 6,	one(0006200),	one(0177700), "#l@s", m68000up },
+{"cmpil", 6,	one(0006200),	one(0177700), "#l$s", m68000up },
 {"cmpil", 6,	one(0006200),	one(0177700), "#lDs", mcfisa_a },
 
 {"cmpmb", 2,	one(0130410),	one(0170770), "+s+d", m68000up },
@@ -275,18 +296,18 @@
 {"cmpml", 2,	one(0130610),	one(0170770), "+s+d", m68000up },
 
 /* The cmp opcode can generate the cmpa, cmpm, and cmpi instructions.  */
-{"cmpb", 4,	one(0006000),	one(0177700), "#b@s", m68000up },
+{"cmpb", 4,	one(0006000),	one(0177700), "#b$s", m68000up },
 {"cmpb", 4,	one(0006000),	one(0177700), "#bDs", mcfisa_b },
 {"cmpb", 2,	one(0130410),	one(0170770), "+s+d", m68000up },
 {"cmpb", 2,	one(0130000),	one(0170700), ";bDd", m68000up },
 {"cmpb", 2,	one(0130000),	one(0170700), "*bDd", mcfisa_b },
 {"cmpw", 2,	one(0130300),	one(0170700), "*wAd", m68000up },
-{"cmpw", 4,	one(0006100),	one(0177700), "#w@s", m68000up },
+{"cmpw", 4,	one(0006100),	one(0177700), "#w$s", m68000up },
 {"cmpw", 4,	one(0006100),	one(0177700), "#wDs", mcfisa_b },
 {"cmpw", 2,	one(0130510),	one(0170770), "+s+d", m68000up },
 {"cmpw", 2,	one(0130100),	one(0170700), "*wDd", m68000up | mcfisa_b },
 {"cmpl", 2,	one(0130700),	one(0170700), "*lAd", m68000up | mcfisa_a },
-{"cmpl", 6,	one(0006200),	one(0177700), "#l@s", m68000up },
+{"cmpl", 6,	one(0006200),	one(0177700), "#l$s", m68000up },
 {"cmpl", 6,	one(0006200),	one(0177700), "#lDs", mcfisa_a },
 {"cmpl", 2,	one(0130610),	one(0170770), "+s+d", m68000up },
 {"cmpl", 2,	one(0130200),	one(0170700), "*lDd", m68000up | mcfisa_a },
@@ -2181,6 +2202,7 @@
 
 const struct m68k_opcode_alias m68k_opcode_aliases[] =
 {
+  { "abcdb",	"abcd", }, /* (TIGCC 20030901) */
   { "add",	"addw", },
   { "adda",	"addaw", },
   { "addi",	"addiw", },
@@ -2188,22 +2210,6 @@
   { "addx",	"addxw", },
   { "asl",	"aslw", },
   { "asr",	"asrw", },
-  { "bhi",	"bhiw", },
-  { "bls",	"blsw", },
-  { "bcc",	"bccw", },
-  { "bcs",	"bcsw", },
-  { "bne",	"bnew", },
-  { "beq",	"beqw", },
-  { "bvc",	"bvcw", },
-  { "bvs",	"bvsw", },
-  { "bpl",	"bplw", },
-  { "bmi",	"bmiw", },
-  { "bge",	"bgew", },
-  { "blt",	"bltw", },
-  { "bgt",	"bgtw", },
-  { "ble",	"blew", },
-  { "bra",	"braw", },
-  { "bsr",	"bsrw", },
   { "bhib",	"bhis", },
   { "blsb",	"blss", },
   { "bccb",	"bccs", },
@@ -2220,17 +2226,17 @@
   { "bleb",	"bles", },
   { "brab",	"bras", },
   { "bsrb",	"bsrs", },
-  { "bhs",	"bccw" },
+  { "bhs",	"bcc" }, /* (TIGCC 20050130) No 'w'. */
   { "bhss",	"bccs" },
   { "bhsb",	"bccs" },
   { "bhsw",	"bccw" },
   { "bhsl",	"bccl" },
-  { "blo",	"bcsw" },
+  { "blo",	"bcs" }, /* (TIGCC 20050130) No 'w'. */
   { "blos",	"bcss" },
   { "blob",	"bcss" },
   { "blow",	"bcsw" },
   { "blol",	"bcsl" },
-  { "br",	"braw", },
+  { "br",	"bra", }, /* (TIGCC 20050130) No 'w'. */
   { "brs",	"bras", },
   { "brb",	"bras", },
   { "brw",	"braw", },
@@ -2279,6 +2285,7 @@
   { "tdivsl",	"divsl", },
   { "divs",	"divsw", },
   { "divu",	"divuw", },
+  { "exgl",	"exg", }, /* (TIGCC 20020512, 20030901) */
   { "ext",	"extw", },
   { "extbw",	"extw", },
   { "extwl",	"extl", },
