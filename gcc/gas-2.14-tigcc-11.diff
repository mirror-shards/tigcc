diff -Naur binutils-2.14.orig/bfd/config.bfd binutils-2.14.tigcc11/bfd/config.bfd
--- binutils-2.14.orig/bfd/config.bfd	Mon Jun  2 22:35:20 2003
+++ binutils-2.14.tigcc11/bfd/config.bfd	Sat Jul 12 09:36:42 2003
@@ -631,7 +631,6 @@
     ;;
   m68*-*-coff* | m68*-*-sysv*)
     targ_defvec=m68kcoff_vec
-    targ_selvecs="m68kcoff_vec versados_vec ieee_vec"
     ;;
   m68*-*-hpux*)
     targ_defvec=hp300hpux_vec
diff -Naur binutils-2.14.orig/gas/as.c binutils-2.14.tigcc11/gas/as.c
--- binutils-2.14.orig/gas/as.c	Tue Apr  8 14:47:06 2003
+++ binutils-2.14.tigcc11/gas/as.c	Wed Jul 16 12:26:28 2003
@@ -242,6 +242,10 @@
                       	  s      include symbols\n\
                       	  =FILE  list to FILE (must be last sub-option)\n"));
 
+/* (TIGCC 20030716) */
+  fprintf (stream, _("\
+  --all-relocs            output all relocs, implies --keep-locals (-L)\n"));
+
   fprintf (stream, _("\
   -D                      produce assembler debugging messages\n"));
   fprintf (stream, _("\
@@ -434,7 +438,10 @@
 #define OPTION_TARGET_HELP (OPTION_STD_BASE + 19)
     {"target-help", no_argument, NULL, OPTION_TARGET_HELP},
 #define OPTION_WARN_FATAL (OPTION_STD_BASE + 20)
-    {"fatal-warnings", no_argument, NULL, OPTION_WARN_FATAL}
+    {"fatal-warnings", no_argument, NULL, OPTION_WARN_FATAL},
+/* (TIGCC 20030716) */
+#define OPTION_ALL_RELOCS (OPTION_STD_BASE + 39)
+    {"all-relocs", no_argument, NULL, OPTION_ALL_RELOCS}
     /* When you add options here, check that they do not collide with
        OPTION_MD_BASE.  See as.h.  */
   };
@@ -769,6 +776,12 @@
 
 	case 'X':
 	  /* -X means treat warnings as errors.  */
+	  break;
+
+	/* (TIGCC 20030716) */
+	case OPTION_ALL_RELOCS:
+	  flag_all_relocs = 1;
+	  flag_keep_locals = 1; /* implies -L */
 	  break;
 	}
     }
diff -Naur binutils-2.14.orig/gas/as.h binutils-2.14.tigcc11/gas/as.h
--- binutils-2.14.orig/gas/as.h	Fri Jan 24 01:12:30 2003
+++ binutils-2.14.tigcc11/gas/as.h	Sun Sep  5 01:40:20 2004
@@ -261,16 +261,22 @@
 
 #ifdef MANY_SEGMENTS
 #include "bfd.h"
-#define N_SEGMENTS 40
-#define SEG_NORMAL(x) ((x) >= SEG_E0 && (x) <= SEG_E39)
-#define SEG_LIST SEG_E0,SEG_E1,SEG_E2,SEG_E3,SEG_E4,SEG_E5,SEG_E6,SEG_E7,SEG_E8,SEG_E9,\
-		 SEG_E10,SEG_E11,SEG_E12,SEG_E13,SEG_E14,SEG_E15,SEG_E16,SEG_E17,SEG_E18,SEG_E19,\
-		 SEG_E20,SEG_E21,SEG_E22,SEG_E23,SEG_E24,SEG_E25,SEG_E26,SEG_E27,SEG_E28,SEG_E29,\
-		 SEG_E30,SEG_E31,SEG_E32,SEG_E33,SEG_E34,SEG_E35,SEG_E36,SEG_E37,SEG_E38,SEG_E39
+/* (TIGCC 20040625) 40 sections are definitely not enough for
+                    -ffunction-sections, -fdata-sections and the like.
+                    So I increased them to 120. -- Kevin Kofler
+   (TIGCC 20040905) And again to 1024. -- Kevin Kofler */
+#define N_SEGMENTS 1024
+#define SEG_NORMAL(x) ((x) >= SEG_E0 && (x) <= SEG_LAST)
+#define LIST_10_(decade) decade##0,decade##1,decade##2,decade##3,decade##4,decade##5,decade##6,decade##7,decade##8,decade##9
+#define LIST_FIRST_100_(century) LIST_10_(century),LIST_10_(century##1),LIST_10_(century##2),LIST_10_(century##3),LIST_10_(century##4),LIST_10_(century##5),LIST_10_(century##6),LIST_10_(century##7),LIST_10_(century##8),LIST_10_(century##9)
+#define LIST_100_(century) LIST_10_(century##0),LIST_10_(century##1),LIST_10_(century##2),LIST_10_(century##3),LIST_10_(century##4),LIST_10_(century##5),LIST_10_(century##6),LIST_10_(century##7),LIST_10_(century##8),LIST_10_(century##9)
+#define LIST_FIRST_1000_(millennium) LIST_FIRST_100_(millennium),LIST_100_(millennium##1),LIST_100_(millennium##2),LIST_100_(millennium##3),LIST_100_(millennium##4),LIST_100_(millennium##5),LIST_100_(millennium##6),LIST_100_(millennium##7),LIST_100_(millennium##8),LIST_100_(millennium##9)
+#define SEG_LIST LIST_FIRST_1000_(SEG_E),LIST_10_(SEG_E100),LIST_10_(SEG_E101),\
+		 SEG_E1020,SEG_E1021,SEG_E1022,SEG_E1023
 #define SEG_TEXT SEG_E0
 #define SEG_DATA SEG_E1
 #define SEG_BSS SEG_E2
-#define SEG_LAST SEG_E39
+#define SEG_LAST SEG_E1023
 #else
 #define N_SEGMENTS 3
 #define SEG_NORMAL(x) ((x) == SEG_TEXT || (x) == SEG_DATA || (x) == SEG_BSS)
@@ -310,8 +316,13 @@
 #ifdef BFD_ASSEMBLER
 #define segment_name(SEG)	bfd_get_section_name (stdoutput, SEG)
 #else
+/* (TIGCC 20040905) Allow arbitrary number of sections here. -- Kevin Kofler */
+#if 0
 extern char const *const seg_name[];
-#define segment_name(SEG)	seg_name[(int) (SEG)]
+#define segment_name(SEG)	seg_name[(int) (SEG)]*/
+#else
+char *segment_name PARAMS ((int));
+#endif
 #endif
 
 #ifndef BFD_ASSEMBLER
@@ -470,6 +481,9 @@
 };
 
 extern enum debug_info_type debug_type;
+
+/* (TIGCC 20030716) True if all relocs should be retained.  */
+COMMON unsigned char flag_all_relocs; /* --all-relocs */
 
 /* Maximum level of macro nesting.  */
 extern int max_macro_nest;
diff -Naur binutils-2.14.orig/gas/config/obj-coff.c binutils-2.14.tigcc11/gas/config/obj-coff.c
--- binutils-2.14.orig/gas/config/obj-coff.c	Thu Dec 12 22:46:46 2002
+++ binutils-2.14.tigcc11/gas/config/obj-coff.c	Sun Sep  5 02:04:20 2004
@@ -1556,7 +1556,7 @@
      section alignment, then skip this step, as TICOFF does.  */
   size = bfd_get_section_size_before_reloc (sec);
   mask = ((bfd_vma) 1 << align_power) - 1;
-#if !defined(TICOFF)
+#if 0 /*!defined(TICOFF)*/
   if (size & mask)
     {
       bfd_vma new_size;
@@ -1699,14 +1699,20 @@
 /* This vector is used to turn a gas internal segment number into a
    section number suitable for insertion into a coff symbol table.
    This must correspond to seg_info_off_by_4.  */
+/* (TIGCC 20040625) 40 sections are definitely not enough for
+                    -ffunction-sections, -fdata-sections and the like.
+                    So I increased them to 120. -- Kevin Kofler */
 
 const short seg_N_TYPE[] =
 {				/* in: segT   out: N_TYPE bits */
+/* (TIGCC 20040905) Allow arbitrary number of sections here. -- Kevin Kofler */
+#if 0
   C_ABS_SECTION,
   1,    2,  3,   4,    5,   6,   7,   8,   9,  10,
   11,  12,  13,  14,  15,  16,  17,  18,  19,  20,
   21,  22,  23,  24,  25,  26,  27,  28,  29,  30,
   31,  32,  33,  34,  35,  36,  37,  38,  39,  40,
+#endif /*0*/
   C_UNDEF_SECTION,		/* SEG_UNKNOWN */
   C_UNDEF_SECTION,		/* SEG_GOOF */
   C_UNDEF_SECTION,		/* SEG_EXPR */
@@ -1716,6 +1722,13 @@
   C_REGISTER_SECTION,		/* SEG_REGISTER */
 };
 
+short SEGMENT_TO_SYMBOL_TYPE (n) int n;
+{
+  if (!n) return C_ABS_SECTION;
+  else if (SEG_NORMAL(n)) return n-SEG_E0+1;
+  else return seg_N_TYPE[n-(N_SEGMENTS+1)];
+}
+
 int function_lineoff = -1;	/* Offset in line#s where the last function
 				   started (the odd entry for line #0) */
 
@@ -1783,6 +1796,8 @@
  SEG_DEBUG,
  SEG_ABSOLUTE,
  SEG_UNKNOWN,
+/* (TIGCC 20040905) Allow arbitrary number of sections here. -- Kevin Kofler */
+#if 0
  SEG_E0,  SEG_E1,  SEG_E2,  SEG_E3,  SEG_E4,
  SEG_E5,  SEG_E6,  SEG_E7,  SEG_E8,  SEG_E9,
  SEG_E10, SEG_E11, SEG_E12, SEG_E13, SEG_E14,
@@ -1801,9 +1816,19 @@
  (segT) 0,
  (segT) 0,
  SEG_REGISTER
+#endif /*0*/
 };
 
-#define SEG_INFO_FROM_SECTION_NUMBER(x) (seg_info_off_by_4[(x)+4])
+static segT SEG_INFO_FROM_SECTION_NUMBER PARAMS ((int));
+
+static segT SEG_INFO_FROM_SECTION_NUMBER (n) int n;
+{
+  if (n<=0) return seg_info_off_by_4[n+4];
+  else if (n<=N_SEGMENTS) return n-1+SEG_E0;
+  else if (n<=N_SEGMENTS+6) return n-1;
+  else if (n==C_REGISTER_SECTION) return SEG_REGISTER;
+  else return 0;
+}
 
 static relax_addressT relax_align PARAMS ((relax_addressT, long));
 
@@ -2025,8 +2050,11 @@
 					S_GET_NAME (symbol_ptr));
 			    }
 
+/* (TIGCC 20030715) Don't convert references to references to the section symbol.
+   (TIGCC 20030805) ... except for local symbols!
+ -- Kevin Kofler  */
 			  dot = segment_info[S_GET_SEGMENT (symbol_ptr)].dot;
-			  if (dot)
+			  if (dot && S_IS_LOCAL(symbol_ptr))
 			    intr.r_symndx = dot->sy_number;
 			  else
 			    intr.r_symndx = symbol_ptr->sy_number;
@@ -3094,6 +3122,11 @@
       tc_frob_coff_symbol (symbolP);
 #endif
 
+      /* (TIGCC 20040725) Clear the SF_LOCAL flag if the symbol is in a
+                          mergeable section. -- Kevin Kofler  */
+     if (segment_info[S_GET_SEGMENT (symbolP)].scnhdr.s_flags & STYP_MERGEABLE)
+       SF_CLEAR_LOCAL (symbolP);
+
       /* We must put the external symbols apart. The loader
 	 does not bomb if we do not. But the references in
 	 the endndx field for a .bb symbol are not corrected
@@ -3435,7 +3468,7 @@
   (!(FRCHAIN)->frch_next || (FRCHAIN)->frch_next->frch_seg != (SEG)	\
    ? get_recorded_alignment (SEG) : 0)
 #else
-#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 1
+#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 0 /*1*/
 #endif
 #endif
 
@@ -3652,7 +3685,9 @@
 {
   unsigned int i;
 
-#ifndef COFF_LONG_SECTION_NAMES
+/* (TIGCC 20040625) Use the full name, not the truncated name, for merging of
+                    identically-named sections. -- Kevin Kofler */
+#if 0 /*ndef COFF_LONG_SECTION_NAMES*/
   char buf[SCNNMLEN + 1];
 
   strncpy (buf, name, SCNNMLEN);
@@ -3755,6 +3790,9 @@
 		case 'w': flags |= STYP_DATA;   break;
 		case 'x': flags |= STYP_TEXT;   break;
 		case 'r': flags |= STYP_LIT;	break;
+/* (TIGCC 20040724) TIGCC COFF extensions for section flags -- Kevin Kofler */
+		case 'm': flags |= STYP_MERGEABLE;	break;
+		case 'u': flags |= STYP_UNALIGNED;	break;
 		default:
 		  as_warn(_("unknown section attribute '%c'"),
 			  *input_line_pointer);
@@ -3915,6 +3953,13 @@
       symbol_remove (symbolP, &symbol_rootP, &symbol_lastP);
       symbol_insert (symbolP, symbol_rootP, &symbol_rootP, &symbol_lastP);
     }
+
+  /* (TIGCC 20030717) In all-relocs mode, add an __ld_all_relocs symbol pointing
+                      to a dummy label in the text section. -- Kevin Kofler  */
+  if (flag_all_relocs) {
+    symbolP = symbol_new("__ld_all_relocs", SEG_TEXT, 0, &zero_address_frag);
+    S_SET_EXTERNAL(symbolP); /* make it an xdef */
+  }
 }
 
 /* Build a 'section static' symbol.  */
@@ -4291,10 +4336,13 @@
 #endif /* TC_I960 */
 	      add_number += S_GET_VALUE (add_symbolP) -
 		S_GET_VALUE (sub_symbolP);
-	      add_symbolP = NULL;
 
 	      if (!TC_FORCE_RELOCATION (fixP))
 		{
+		  /* (TIGCC 20030717) Zero out add_symbolP only if !TC_FORCE_RELOCATION.
+		                      -- Kevin Kofler  */
+		  add_symbolP = NULL;
+
 		  fixP->fx_addsy = NULL;
 		  fixP->fx_subsy = NULL;
 		  fixP->fx_done = 1;
@@ -4319,6 +4367,8 @@
 #endif
 		       )
 		{
+/* (TIGCC 20030716) Take TC_FORCE_RELOCATION_SUB_LOCAL into account. -- Kevin Kofler  */
+		 if (!TC_FORCE_RELOCATION_SUB_LOCAL (fixP)) {
 		  /* Make it pc-relative.  */
 		  add_number += (md_pcrel_from (fixP)
 				 - S_GET_VALUE (sub_symbolP));
@@ -4326,15 +4376,19 @@
 		  fixP->fx_pcrel = 1;
 		  sub_symbolP = 0;
 		  fixP->fx_subsy = 0;
+		 }
 		}
 #endif
 	      else
 		{
+/* (TIGCC 20030716) Take UNDEFINED_DIFFERENCE_OK into account. -- Kevin Kofler  */
+#ifndef UNDEFINED_DIFFERENCE_OK
 		  as_bad_where (fixP->fx_file, fixP->fx_line,
 				_("Can't emit reloc {- %s-seg symbol \"%s\"} @ file address %ld."),
 				segment_name (S_GET_SEGMENT (sub_symbolP)),
 				S_GET_NAME (sub_symbolP),
 				(long) (fragP->fr_address + where));
+#endif
 		}
 	    }
 	}
@@ -4473,7 +4527,13 @@
 
       md_apply_fix3 (fixP, (valueT *) & add_number, this_segment_type);
 
-      if (!fixP->fx_bit_fixP && ! fixP->fx_no_overflow)
+/* (TIGCC 20030716) Reuse fx_im_disp to turn off range checking on the 68k.
+                    -- Kevin Kofler  */
+      if (!fixP->fx_bit_fixP && ! fixP->fx_no_overflow
+#ifdef TC_M68K
+          && !fixP->fx_im_disp
+#endif
+      )
 	{
 #ifndef TC_M88K
 	  /* The m88k uses the offset field of the reloc to get around
diff -Naur binutils-2.14.orig/gas/config/obj-coff.h binutils-2.14.tigcc11/gas/config/obj-coff.h
--- binutils-2.14.orig/gas/config/obj-coff.h	Fri Apr  4 10:15:14 2003
+++ binutils-2.14.tigcc11/gas/config/obj-coff.h	Sun Sep  5 01:33:44 2004
@@ -477,7 +477,8 @@
 #define C_DEBUG_SECTION		N_DEBUG
 #define C_NTV_SECTION		N_TV
 #define C_PTV_SECTION		P_TV
-#define C_REGISTER_SECTION	50
+/* (TIGCC 20040905) Don't hardcode number of sections here. -- Kevin Kofler */
+#define C_REGISTER_SECTION	(N_SEGMENTS+10)
 
 /* Macros to extract information from a symbol table entry.
    This syntaxic indirection allows independence regarding a.out or coff.
@@ -500,20 +501,31 @@
 /* Return true for symbols that should not be reduced to section
    symbols or eliminated from expressions, because they may be
    overridden by the linker.  */
+/* (TIGCC 20030716) Never reduce or eliminate relocs in all-relocs mode.
+   (TIGCC 20040719) Don't force relocs for absolute symbols if !flag_all_relocs.
+   (TIGCC 20040725) Force relocs for symbols in mergeable sections.
+                    -- Kevin Kofler  */
 #define S_FORCE_RELOC(s, strict) \
-  (!SEG_NORMAL (S_GET_SEGMENT (s)) || (strict && S_IS_WEAK (s)))
+  ((!SEG_NORMAL (S_GET_SEGMENT (s)) && S_GET_SEGMENT (s) != absolute_section) \
+   || (strict && S_IS_WEAK (s)) || flag_all_relocs \
+   || (segment_info[S_GET_SEGMENT (s)].scnhdr.s_flags & STYP_MERGEABLE))
 
 /* True if a debug special symbol entry.  */
 #define S_IS_DEBUG(s) \
   ((s)->sy_symbol.ost_entry.n_scnum == C_DEBUG_SECTION)
 
 /* True if a symbol is local symbol name.  */
-/* A symbol name whose name includes ^A is a gas internal pseudo symbol.  */
+/* A symbol name whose name includes ^A is a gas internal pseudo symbol.
+   (TIGCC 20030716) However, we want them output when outputting local symbols.
+   (TIGCC 20040724) Also, we always want to output local symbols in mergeable
+                    sections, because our linker relies on that.
+                    -- Kevin Kofler  */
 #define S_IS_LOCAL(s) \
   ((s)->sy_symbol.ost_entry.n_scnum == C_REGISTER_SECTION \
-   || (S_LOCAL_NAME(s) && ! flag_keep_locals && ! S_IS_DEBUG (s)) \
-   || strchr (S_GET_NAME (s), '\001') != NULL \
-   || strchr (S_GET_NAME (s), '\002') != NULL \
+   || (S_LOCAL_NAME(s) && ! flag_keep_locals && ! S_IS_DEBUG (s) \
+       && !(segment_info[S_GET_SEGMENT (s)].scnhdr.s_flags & STYP_MERGEABLE)) \
+   || (strchr (S_GET_NAME (s), '\001') != NULL && ! flag_keep_locals) \
+   || (strchr (S_GET_NAME (s), '\002') != NULL && ! flag_keep_locals) \
    || (flag_strip_local_absolute \
        && !S_IS_EXTERNAL(s) \
        && (s)->sy_symbol.ost_entry.n_scnum == C_ABS_SECTION))
diff -Naur binutils-2.14.orig/gas/config/tc-m68k.c binutils-2.14.tigcc11/gas/config/tc-m68k.c
--- binutils-2.14.orig/gas/config/tc-m68k.c	Thu Dec 12 22:16:16 2002
+++ binutils-2.14.tigcc11/gas/config/tc-m68k.c	Mon Sep 20 19:08:14 2004
@@ -75,6 +75,7 @@
 int flag_want_pic;
 
 static int flag_short_refs;	/* -l option */
+static int flag_short_jumps;	/* --short-jumps option */
 static int flag_long_jumps;	/* -S option */
 static int flag_keep_pcrel;	/* --pcrel option.  */
 
@@ -692,15 +693,24 @@
 tc_coff_fix2rtype (fixP)
      fixS *fixP;
 {
+/* (TIGCC 20040920) Handle unoptimizable relocs.  -- Kevin Kofler */
+  short isunopt;
+  isunopt = (fixP->fx_unoptimizable) ? R_UNOPTIMIZABLE : 0;
+
   if (fixP->fx_tcbit && fixP->fx_size == 4)
-    return R_RELLONG_NEG;
+    return isunopt | R_RELLONG_NEG;
+/* (TIGCC 20030716) Handle word and byte negative relocs.  -- Kevin Kofler */
+  if (fixP->fx_tcbit && fixP->fx_size == 2)
+    return isunopt | R_RELWORD_NEG;
+  if (fixP->fx_tcbit && fixP->fx_size == 1)
+    return isunopt | R_RELBYTE_NEG;
 #ifdef NO_PCREL_RELOCS
   know (fixP->fx_pcrel == 0);
-  return (fixP->fx_size == 1 ? R_RELBYTE
+  return isunopt | (fixP->fx_size == 1 ? R_RELBYTE
 	  : fixP->fx_size == 2 ? R_DIR16
 	  : R_DIR32);
 #else
-  return (fixP->fx_pcrel ?
+  return isunopt | (fixP->fx_pcrel ?
 	  (fixP->fx_size == 1 ? R_PCRBYTE :
 	   fixP->fx_size == 2 ? R_PCRWORD :
 	   R_PCRLONG) :
@@ -2574,8 +2584,15 @@
 		    the_ins.opcode[0] = 0x4EB9;
 		  else					/* jCC */
 		    {
+		      /* (TIGCC 20030902) Add a PC-relative reloc (unconditionally, because
+		                          it will be removed later on if not in all-relocs
+		                          mode). -- Kevin Kofler  */
+		      struct m68k_exp temp_expr = {SIZE_UNSPEC,
+		      {symbol_new (FAKE_LABEL_NAME, now_seg, (valueT) frag_now_fix () + 8, frag_now),
+		      NULL, 0, O_symbol, 0, 0}};
 		      the_ins.opcode[0] ^= 0x0100;
 		      the_ins.opcode[0] |= 0x0006;
+		      add_fix ('B' /*case-sensitive!*/, &temp_expr, 1 /*PCREL*/, -1 /*PCREL fix for bytes*/);
 		      addword (0x4EF9);
 		    }
 		  add_fix ('l', &opP->disp, 0, 0);
@@ -3659,6 +3676,12 @@
 			      get_reloc_code (n, the_ins.reloc[m].pcrel,
 					      the_ins.reloc[m].pic_reloc));
 	  fixP->fx_pcrel_adjust = the_ins.reloc[m].pcrel_fix;
+	  /* (TIGCC 20040920) Only source operands are optimizable. However, we have
+	     to account for an ugly special case: jbcc pseudo-opcodes, which are
+	     actually 2 instructions. -- Kevin Kofler */
+	  if ((the_ins.reloc[m].n > 4) || (the_ins.reloc[m].n == 3)
+	      || ((the_ins.reloc[m].n == 4) && ((the_ins.opcode[0]&0xf000) != 0x6000)))
+	    fixP->fx_unoptimizable = 1;
 	  if (the_ins.reloc[m].wid == 'B')
 	    fixP->fx_signed = 1;
 	}
@@ -3721,6 +3744,12 @@
 			      get_reloc_code (wid, the_ins.reloc[m].pcrel,
 					      the_ins.reloc[m].pic_reloc));
 	  fixP->fx_pcrel_adjust = the_ins.reloc[m].pcrel_fix;
+	  /* (TIGCC 20040920) Only source operands are optimizable. However, we have
+	     to account for an ugly special case: jbcc pseudo-opcodes, which are
+	     actually 2 instructions. -- Kevin Kofler */
+	  if ((the_ins.reloc[m].n > 4) || (the_ins.reloc[m].n == 3)
+	      || ((the_ins.reloc[m].n == 4) && ((the_ins.opcode[0]&0xf000) != 0x6000)))
+	    fixP->fx_unoptimizable = 1;
 	}
       (void) frag_var (rs_machine_dependent, 10, 0,
 		       (relax_substateT) (the_ins.fragb[n].fragty),
@@ -3758,6 +3787,12 @@
 			  get_reloc_code (wid, the_ins.reloc[m].pcrel,
 					  the_ins.reloc[m].pic_reloc));
       fixP->fx_pcrel_adjust = the_ins.reloc[m].pcrel_fix;
+      /* (TIGCC 20040920) Only source operands are optimizable. However, we have
+         to account for an ugly special case: jbcc pseudo-opcodes, which are
+         actually 2 instructions. -- Kevin Kofler */
+      if ((the_ins.reloc[m].n > 4) || (the_ins.reloc[m].n == 3)
+          || ((the_ins.reloc[m].n == 4) && ((the_ins.opcode[0]&0xf000) != 0x6000)))
+        fixP->fx_unoptimizable = 1;
     }
 }
 
@@ -4241,7 +4276,9 @@
 
   val = ((val & 0xffffffff) ^ 0x80000000) - 0x80000000;
 
-  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
+/* (TIGCC 20030716) We aren't done when we still have something to subtract.
+                    -- Kevin Kofler  */
+  if (fixP->fx_addsy == NULL && fixP->fx_subsy == NULL && fixP->fx_pcrel == 0)
     fixP->fx_done = 1;
 
 #ifdef OBJ_ELF
@@ -4264,6 +4301,55 @@
     return;
 #endif
 
+  /* Fix up a negative reloc.  */
+  if (fixP->fx_addsy == NULL && fixP->fx_subsy != NULL)
+    {
+      fixP->fx_addsy = fixP->fx_subsy;
+      fixP->fx_subsy = NULL;
+      fixP->fx_tcbit = 1;
+      val = -val; /* (TIGCC 20030716) */
+    }
+  /* (TIGCC 20030716) Fix up an address difference by splitting it into its
+                      components.
+                      Fix up subtraction of the dot symbol by changing the reloc
+                      to PC-relative (disabled 20030717).  -- Kevin Kofler
+     (TIGCC 20040807) For common symbols, the value is the size, not the
+                      position, so don't use it.  -- Kevin Kofler  */
+  else if (fixP->fx_addsy != NULL && fixP->fx_subsy != NULL)
+    {
+#if 0 /* (TIGCC 20030717) This is unnecessary (see expr.c fix) and probably wrong. */
+      if (!~fixP->fx_subsy->sy_number) { /* detect the dot symbol */
+        /* make the reloc PC-relative: */
+        val += md_pcrel_from (fixP);
+        fixP->fx_offset = *valP = val;
+        fixP->fx_pcrel = 1;
+        fixP->fx_subsy = NULL;
+      } else {
+#endif
+        fixS *negreloc = fix_new (fixP->fx_frag, fixP->fx_where, fixP->fx_size,
+                                  fixP->fx_subsy, fixP->fx_offset
+                                                  + (S_IS_COMMON (fixP->fx_addsy) ? 0 : S_GET_VALUE (fixP->fx_addsy))
+                                                  + segment_info[S_GET_SEGMENT (fixP->fx_addsy)].scnhdr.s_paddr
+                                                  - (((S_IS_COMMON (fixP->fx_subsy) ? 0 : S_GET_VALUE (fixP->fx_subsy))
+                                                     + segment_info[S_GET_SEGMENT (fixP->fx_subsy)].scnhdr.s_paddr)
+                                                     << 1) /* (TIGCC 20030717) Yes, we need to subtract this twice!
+                                                               This kludge compensates for later incorrect
+                                                               computations in obj-coff.c. -- Kevin Kofler  */,
+                                  0, 0);
+        if (negreloc) {
+          fixP->fx_offset = 0; /* We have transferred the offset to the negative reloc.  */
+          fixP->fx_pcrel = 0;
+          fixP->fx_subsy = NULL;
+          negreloc->fx_tcbit = 1;
+          /* turn off range checking for both relocs: */
+          fixP->fx_im_disp = negreloc->fx_im_disp = 1;
+        }
+#if 0
+      }
+#endif
+    }
+
+  /* (TIGCC 20030716) Moved this down so val can be adjusted. -- Kevin Kofler  */
   switch (fixP->fx_size)
     {
       /* The cast to offsetT below are necessary to make code
@@ -4291,13 +4377,8 @@
       BAD_CASE (fixP->fx_size);
     }
 
-  /* Fix up a negative reloc.  */
-  if (fixP->fx_addsy == NULL && fixP->fx_subsy != NULL)
-    {
-      fixP->fx_addsy = fixP->fx_subsy;
-      fixP->fx_subsy = NULL;
-      fixP->fx_tcbit = 1;
-    }
+  /* (TIGCC 20030716) Reuse fx_im_disp to turn off range checking. -- Kevin Kofler  */
+  if (fixP->fx_im_disp) return;
 
   /* For non-pc-relative values, it's conceivable we might get something
      like "0xff" for a byte field.  So extend the upper part of the range
@@ -4412,6 +4493,27 @@
       fragP->fr_opcode[0] ^= 0x01;	/* invert bcc */
       fragP->fr_opcode[1] = 0x6;/* branch offset = 6 */
 
+      /* (TIGCC 20030902) Add a PC-relative reloc (unconditionally, because
+                          it will be removed later on if not in all-relocs
+                          mode).  -- Kevin Kofler
+         (TIGCC 20030908) Unfortunately, we cannot create symbols here for some
+                          reason, so we create the symbol in advance in
+                          md_estimate_size_before_relax and store it into the
+                          frag structure of the next frag. Here, we only have to
+                          read it.  -- Kevin Kofler, patch by Sebastian Reichelt
+         */
+      {
+	fragS *nextFragP = fragP->fr_next;
+	symbolS *symbolP = NULL;
+	if (nextFragP)
+	  symbolP = nextFragP->fr_start_symbol;
+
+	if (symbolP)
+	  fix_new (fragP, fragP->fr_fix - 1, 1, symbolP, -1, 1, RELAX_RELOC_PC8);
+	else
+	  as_warn_where (fragP->fr_file, fragP->fr_line, _("no symbol available for pseudo-op code"));
+      }
+
       /* JF: these used to be fr_opcode[2,3], but they may be in a
 	   different frag, in which case refering to them is a no-no.
 	   Only fr_opcode[0,1] are guaranteed to work.  */
@@ -4578,8 +4680,17 @@
 	    && relaxable_symbol (fragP->fr_symbol))
 	  {
 	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), BYTE);
+	    /* (TIGCC 20030909) Create a symbol at the beginning of the next frag
+	                        and store it into the frag structure, because
+	                        md_convert_frag_1 might need a symbol there, but
+	                        can't create it itself. This is necessary only for
+	                        conditional jumps. -- Kevin Kofler  */
+	    if ((TABTYPE (fragP->fr_subtype) == BRABSJCOND) && fragP->fr_next)
+	      {
+		fragP->fr_next->fr_start_symbol = symbol_new (FAKE_LABEL_NAME, segment, fragP->fr_next->fr_address, fragP->fr_next);
+	      }
 	  }
-	else if (flag_short_refs)
+	else if (flag_short_jumps)
 	  {
 	    /* Symbol is undefined and we want short ref.  */
 	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
@@ -4588,6 +4699,17 @@
 	  {
 	    /* Symbol is still undefined.  Make it LONG.  */
 	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), LONG);
+	    /* (TIGCC 20030908) Create a symbol at the beginning of the next frag
+	                        and store it into the frag structure, because
+	                        md_convert_frag_1 might need a symbol there, but
+	                        can't create it itself.
+	                        -- Kevin Kofler, patch by Sebastian Reichelt
+	       (TIGCC 20030909) This is necessary only for conditional jumps.
+	                        -- Kevin Kofler  */
+	    if ((TABTYPE (fragP->fr_subtype) == BRABSJCOND) && fragP->fr_next)
+	      {
+		fragP->fr_next->fr_start_symbol = symbol_new (FAKE_LABEL_NAME, segment, fragP->fr_next->fr_address, fragP->fr_next);
+	      }
 	  }
 	break;
       }
@@ -4614,7 +4736,7 @@
       {
 	if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
 	     && relaxable_symbol (fragP->fr_symbol))
-	    || flag_short_refs)
+	    || flag_short_jumps)
 	  {
 	    fragP->fr_subtype = TAB (TABTYPE (fragP->fr_subtype), SHORT);
 	  }
@@ -4640,7 +4762,8 @@
     case TAB (ABSTOPCREL, SZ_UNDEF):
       {
 	if ((S_GET_SEGMENT (fragP->fr_symbol) == segment
-	     && relaxable_symbol (fragP->fr_symbol)))
+	     && relaxable_symbol (fragP->fr_symbol))
+	    || flag_short_refs)
 	  {
 	    fragP->fr_subtype = TAB (ABSTOPCREL, SHORT);
 	  }
@@ -4684,6 +4807,7 @@
 	    }
 	}
       break;
+
     default:
       break;
     }
@@ -6753,6 +6877,8 @@
   {"disp-size-default-32", no_argument, NULL, OPTION_DISP_SIZE_DEFAULT_32},
 #define OPTION_PCREL (OPTION_MD_BASE + 7)
   {"pcrel", no_argument, NULL, OPTION_PCREL},
+#define OPTION_SHORT_JUMPS (OPTION_MD_BASE + 8)
+  {"short-jumps", no_argument, NULL, OPTION_SHORT_JUMPS},
   {NULL, no_argument, NULL, 0}
 };
 size_t md_longopts_size = sizeof (md_longopts);
@@ -6767,6 +6893,12 @@
     case 'l':			/* -l means keep external to 2 bit offset
 				   rather than 16 bit one */
       flag_short_refs = 1;
+      flag_short_jumps = 1;
+      break;
+
+    case OPTION_SHORT_JUMPS:	/* --short-jumps is like -l only for
+				   jumps.  */
+      flag_short_jumps = 1;
       break;
 
     case 'S':			/* -S means that jbsr's always turn into
@@ -6946,6 +7078,7 @@
   fprintf (stream, _("\
 680X0 options:\n\
 -l			use 1 word for refs to undefined symbols [default 2]\n\
+--short-jumps		use 1 word for jumps to undefined symbols [default 2]\n\
 -m68000 | -m68008 | -m68010 | -m68020 | -m68030 | -m68040 | -m68060 |\n\
 -m68302 | -m68331 | -m68332 | -m68333 | -m68340 | -m68360 | -mcpu32 |\n\
 -m5200  | -m5202  | -m5204  | -m5206  | -m5206e | -m5307  | -m5407\n\
diff -Naur binutils-2.14.orig/gas/config/tc-m68k.h binutils-2.14.tigcc11/gas/config/tc-m68k.h
--- binutils-2.14.orig/gas/config/tc-m68k.h	Thu Jan 23 12:51:04 2003
+++ binutils-2.14.tigcc11/gas/config/tc-m68k.h	Wed Jul 16 11:48:34 2003
@@ -220,3 +220,19 @@
   while (0)
 
 #define DWARF2_LINE_MIN_INSN_LENGTH 2
+
+/* (TIGCC 20030716) Allow difference of undefined symbols. -- Kevin Kofler  */
+#define UNDEFINED_DIFFERENCE_OK
+
+/* (TIGCC 20030716) Force relocs in all-relocs mode. -- Kevin Kofler  */
+#define TC_FORCE_RELOCATION(FIX)		\
+  (generic_force_reloc (FIX))
+#define TC_FORCE_RELOCATION_ABS(FIX)		\
+  (0)
+#define TC_FORCE_RELOCATION_LOCAL(FIX)		\
+  (TC_FORCE_RELOCATION (FIX))
+#define TC_FORCE_RELOCATION_SUB_SAME(FIX, SEG)	\
+  (! SEG_NORMAL (SEG) || TC_FORCE_RELOCATION (FIX))
+#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX)	\
+  (TC_FORCE_RELOCATION (FIX))
+/* (END TIGCC 20030716) */
diff -Naur binutils-2.14.orig/gas/expr.c binutils-2.14.tigcc11/gas/expr.c
--- binutils-2.14.orig/gas/expr.c	Fri Oct 18 03:56:38 2002
+++ binutils-2.14.tigcc11/gas/expr.c	Mon Jul 19 07:23:24 2004
@@ -1740,8 +1740,11 @@
 	  /* X + constant.  */
 	  resultP->X_add_number += right.X_add_number;
 	}
-      /* This case comes up in PIC code.  */
-      else if (op_left == O_subtract
+      /* This case comes up in PIC code.
+         (TIGCC 20040719) This optimization isn't valid in all-relocs mode.
+                          -- Kevin Kofler  */
+      else if (!flag_all_relocs
+	       && op_left == O_subtract
 	       && right.X_op == O_symbol
 	       && resultP->X_op == O_symbol
 	       && (symbol_get_frag (right.X_add_symbol)
@@ -1837,6 +1840,15 @@
 		       && right.X_add_number == 0)))
 	{
 	  /* Symbol OP symbol.  */
+
+	  /* (TIGCC 20030717) Optimize .set sym2,sym3+c; sym1-sym2 to
+	     .set sym2,sym3+c; sym1-(sym3+c). The code below will further change
+	     this to .set sym2,sym3+c; (sym1-c)-sym3. -- Kevin Kofler  */
+	  if (!right.X_add_number && right.X_add_symbol->sy_value.X_op == O_symbol) {
+	    resolve_symbol_value(right.X_add_symbol);
+	    memcpy(&right, &right.X_add_symbol->sy_value, sizeof(expressionS));
+	  }
+
 	  resultP->X_op = op_left;
 	  resultP->X_op_symbol = right.X_add_symbol;
 	  if (op_left == O_add)
diff -Naur binutils-2.14.orig/gas/frags.h binutils-2.14.tigcc11/gas/frags.h
--- binutils-2.14.orig/gas/frags.h	Fri May  3 04:25:32 2002
+++ binutils-2.14.tigcc11/gas/frags.h	Mon Sep  8 23:25:34 2003
@@ -66,6 +66,9 @@
   char *fr_file;
   unsigned int fr_line;
 
+  /* (TIGCC) Symbol at the beginning of the frag. May be NULL.  */
+  symbolS *fr_start_symbol;
+
 #ifndef NO_LISTING
   struct list_info_struct *line;
 #endif
diff -Naur binutils-2.14.orig/gas/listing.c binutils-2.14.tigcc11/gas/listing.c
--- binutils-2.14.orig/gas/listing.c	Wed Jun 26 03:18:42 2002
+++ binutils-2.14.tigcc11/gas/listing.c	Mon Sep  1 23:26:54 2003
@@ -976,7 +976,8 @@
   int show_listing = 1;
   unsigned int width;
 
-  buffer = xmalloc (listing_rhs_width);
+  buffer = xmalloc (listing_rhs_width + 1); /* (TIGCC 20030901) Add 1 for the
+    terminating '\0' character. -- Kevin Kofler  */
   data_buffer = xmalloc (MAX_BYTES);
   eject = 1;
   list = head;
@@ -995,8 +996,8 @@
     {
       unsigned int list_line;
 
-      width = listing_rhs_width > paper_width ? paper_width :
-	listing_rhs_width;
+      width = (listing_rhs_width > paper_width ? paper_width :
+	listing_rhs_width) + 1; /* (TIGCC 20030901) See above.  */
 
       list_line = list->line;
       switch (list->edict)
diff -Naur binutils-2.14.orig/gas/read.c binutils-2.14.tigcc11/gas/read.c
--- binutils-2.14.orig/gas/read.c	Mon Jun  2 22:35:22 2003
+++ binutils-2.14.tigcc11/gas/read.c	Mon Sep 20 17:38:38 2004
@@ -3759,8 +3759,9 @@
 #define TC_CONS_RELOC 0
 #endif
 #endif
+      /* (TIGCC 20040920) Constants aren't optimizable relocs. -- Kevin Kofler */
       fix_new_exp (frag_now, p - frag_now->fr_literal, (int) nbytes, exp, 0,
-		   TC_CONS_RELOC);
+		   TC_CONS_RELOC) -> fx_unoptimizable = 1;
 #endif /* TC_CONS_FIX_NEW */
 #endif /* BFD_ASSEMBLER */
     }
diff -Naur binutils-2.14.orig/gas/subsegs.c binutils-2.14.tigcc11/gas/subsegs.c
--- binutils-2.14.orig/gas/subsegs.c	Sun Dec  8 03:47:56 2002
+++ binutils-2.14.tigcc11/gas/subsegs.c	Sun Sep  5 01:53:14 2004
@@ -41,6 +41,8 @@
 
 #endif /* MANY_SEGMENTS */
 char const *const seg_name[] = {
+/* (TIGCC 20040905) Allow arbitrary number of sections here. -- Kevin Kofler */
+#if 0
   "absolute",
 #ifdef MANY_SEGMENTS
   "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9",
@@ -52,6 +54,7 @@
   "data",
   "bss",
 #endif /* MANY_SEGMENTS */
+#endif /* 0 */
   "unknown",
   "ASSEMBLER-INTERNAL-LOGIC-ERROR!",
   "expr",
@@ -61,6 +64,17 @@
   "register",
   "",
 };				/* Used by error reporters, dumpers etc.  */
+
+char *segment_name (n) int n;
+{
+  if (!n) return "absolute";
+  else if (SEG_NORMAL(n)) {
+    static char s[8];
+    sprintf(s,"e%d",n-SEG_E0);
+    return s;
+  } else return seg_name[n-(N_SEGMENTS+1)];
+}
+
 #else /* BFD_ASSEMBLER */
 
 /* Gas segment information for bfd_abs_section_ptr and
diff -Naur binutils-2.14.orig/gas/symbols.c binutils-2.14.tigcc11/gas/symbols.c
--- binutils-2.14.orig/gas/symbols.c	Fri Jan 24 01:12:30 2003
+++ binutils-2.14.tigcc11/gas/symbols.c	Mon Jul 19 18:02:20 2004
@@ -1155,6 +1155,14 @@
 		       || add_symbol == op_symbol)))
 	    report_op_error (symp, add_symbol, op_symbol);
 
+	  /* (TIGCC 20040719) In all-relocs mode, we can't apply operations other
+	                      than + or - on an address or address difference.
+	                      -- Kevin Kofler */
+	  if (flag_all_relocs && finalize_syms
+	      && !(op == O_subtract || op == O_add)
+	      && final_seg == undefined_section)
+	    report_op_error (symp, add_symbol, op_symbol);
+
 	  if (final_seg == expr_section || final_seg == undefined_section)
 	    final_seg = absolute_section;
 
diff -Naur binutils-2.14.orig/gas/symbols.h binutils-2.14.tigcc11/gas/symbols.h
--- binutils-2.14.orig/gas/symbols.h	Thu Jan 23 12:51:04 2003
+++ binutils-2.14.tigcc11/gas/symbols.h	Sun Sep  5 01:14:02 2004
@@ -138,11 +138,16 @@
 /*
  * Current means for getting from symbols to segments and vice verse.
  * This will change for infinite-segments support (e.g. COFF).
+ * (TIGCC 20040905) And indeed it does. -- Kevin Kofler
  */
 extern const segT N_TYPE_seg[];	/* subseg.c */
 
+#if 0
 #define	SEGMENT_TO_SYMBOL_TYPE(seg)  ( seg_N_TYPE [(int) (seg)] )
 extern const short seg_N_TYPE[];/* subseg.c */
+#else
+short SEGMENT_TO_SYMBOL_TYPE PARAMS ((int seg));
+#endif
 
 #define	N_REGISTER	30	/* Fake N_TYPE value for SEG_REGISTER */
 
diff -Naur binutils-2.14.orig/gas/write.c binutils-2.14.tigcc11/gas/write.c
--- binutils-2.14.orig/gas/write.c	Mon Apr  7 05:54:00 2003
+++ binutils-2.14.tigcc11/gas/write.c	Mon Sep 20 17:20:00 2004
@@ -224,6 +224,7 @@
 #if defined(NEED_FX_R_TYPE) || defined (BFD_ASSEMBLER)
   fixP->fx_r_type = r_type;
 #endif
+  fixP->fx_unoptimizable = 0; /* (TIGCC 20040920) */
   fixP->fx_im_disp = 0;
   fixP->fx_pcrel_adjust = 0;
   fixP->fx_bit_fixP = 0;
@@ -863,6 +864,11 @@
 	    continue;
 	  }
 
+	/* (TIGCC 20030716) Only reduce relocs which refer to local symbols we
+	                    aren't going to output. -- Kevin Kofler  */
+	if (! S_IS_LOCAL (sym))
+		continue;
+
 	/* Don't try to reduce relocs which refer to non-local symbols
            in .linkonce sections.  It can lead to confusion when a
            debugging section refers to a .linkonce section.  I hope
@@ -1419,7 +1425,7 @@
       /* This now gets called even if we had errors.  In that case,
          any alignment is meaningless, and, moreover, will look weird
          if we are generating a listing.  */
-      if (!had_errors ())
+      if (0 /*!had_errors ()*/)
 	{
 	  alignment = SUB_SEGMENT_ALIGN (now_seg, frchainP);
 #ifdef BFD_ASSEMBLER
diff -Naur binutils-2.14.orig/gas/write.h binutils-2.14.tigcc11/gas/write.h
--- binutils-2.14.orig/gas/write.h	Fri Sep 20 01:51:34 2002
+++ binutils-2.14.tigcc11/gas/write.h	Mon Sep 20 17:16:44 2004
@@ -69,9 +69,12 @@
      look into it for version 2.6.  */
   unsigned fx_plt : 1;
 
+  /* (TIGCC 20040920) Is this an unoptimizable reloc? -- Kevin Kofler  */
+  unsigned fx_unoptimizable : 1;
+
   /* Is this value an immediate displacement?  */
   /* Only used on i960 and ns32k; merge it into TC_FIX_TYPE sometime.  */
-  unsigned fx_im_disp : 2;
+  unsigned fx_im_disp : 1;
 
   /* A bit for the CPU specific code.
      This probably can be folded into tc_fix_data, below.  */
diff -Naur binutils-2.14.orig/include/coff/internal.h binutils-2.14.tigcc11/include/coff/internal.h
--- binutils-2.14.orig/include/coff/internal.h	Wed Aug 28 12:38:48 2002
+++ binutils-2.14.tigcc11/include/coff/internal.h	Mon Sep 20 17:30:42 2004
@@ -345,6 +345,9 @@
 
 #define STYP_LIT	0x8020	/* Literal data (like STYP_TEXT) */
 
+/* (TIGCC 20040724) TIGCC COFF extensions for section flags -- Kevin Kofler */
+#define STYP_MERGEABLE 0x1000000
+#define STYP_UNALIGNED 0x2000000
 
 /********************** LINE NUMBERS **********************/
 
@@ -737,5 +740,10 @@
 #define R_W65_PCR16	9
 
 #define R_W65_DP       10  /* direct page 8 bits only   */
+
+/* (TIGCC 20030716, 20040920) TIGCC COFF extensions -- Kevin Kofler  */
+#define R_RELWORD_NEG 0x7161
+#define R_RELBYTE_NEG 0x7162
+#define R_UNOPTIMIZABLE 0x8000
 
 #endif /* GNU_COFF_INTERNAL_H */
diff -Naur binutils-2.14.orig/opcodes/configure binutils-2.14.tigcc11/opcodes/configure
--- binutils-2.14.orig/opcodes/configure	Mon Jun  2 22:35:16 2003
+++ binutils-2.14.tigcc11/opcodes/configure	Sat Jul 12 09:36:42 2003
@@ -487,7 +487,7 @@
 
 # A filename unique to this package, relative to the directory that
 # configure is in, which we can look for to find out if srcdir is correct.
-ac_unique_file=z8k-dis.c
+ac_unique_file=m68k-dis.c
 
 # Find the source files, if location was not specified.
 if test -z "$srcdir"; then
diff -Naur binutils-2.14.orig/opcodes/configure.in binutils-2.14.tigcc11/opcodes/configure.in
--- binutils-2.14.orig/opcodes/configure.in	Mon Jun  2 22:35:16 2003
+++ binutils-2.14.tigcc11/opcodes/configure.in	Sat Jul 12 09:36:42 2003
@@ -2,7 +2,7 @@
 dnl
 
 AC_PREREQ(2.13)
-AC_INIT(z8k-dis.c)
+AC_INIT(m68k-dis.c)
 
 AC_CANONICAL_SYSTEM
 AC_ISC_POSIX
diff -Naur binutils-2.14.orig/opcodes/m68k-opc.c binutils-2.14.tigcc11/opcodes/m68k-opc.c
--- binutils-2.14.orig/opcodes/m68k-opc.c	Mon Nov 12 16:36:06 2001
+++ binutils-2.14.tigcc11/opcodes/m68k-opc.c	Mon Sep  1 23:12:36 2003
@@ -251,6 +251,7 @@
 
 {"clrb",	one(0041000),	one(0177700), "$s", m68000up | mcf },
 {"clrw",	one(0041100),	one(0177700), "$s", m68000up | mcf },
+{"clrl",	one(0070000),	one(0170477), "Dd", m68000 },
 {"clrl",	one(0041200),	one(0177700), "$s", m68000up | mcf },
 
 {"cmp2b",	two(0000300,0), two(0177700,07777), "!sR1", m68020up | cpu32 },
@@ -260,11 +261,11 @@
 {"cmpaw",	one(0130300),	one(0170700), "*wAd", m68000up },
 {"cmpal",	one(0130700),	one(0170700), "*lAd", m68000up | mcf },
 
-{"cmpib",	one(0006000),	one(0177700), "#b@s", m68000up },
+{"cmpib",	one(0006000),	one(0177700), "#b$s", m68000up },
 {"cmpib",	one(0006000),	one(0177700), "#bDs", mcf5407 },
-{"cmpiw",	one(0006100),	one(0177700), "#w@s", m68000up },
+{"cmpiw",	one(0006100),	one(0177700), "#w$s", m68000up },
 {"cmpiw",	one(0006100),	one(0177700), "#wDs", mcf5407 },
-{"cmpil",	one(0006200),	one(0177700), "#l@s", m68000up },
+{"cmpil",	one(0006200),	one(0177700), "#l$s", m68000up },
 {"cmpil",	one(0006200),	one(0177700), "#lDs", mcf },
 
 {"cmpmb",	one(0130410),	one(0170770), "+s+d", m68000up },
@@ -272,18 +273,18 @@
 {"cmpml",	one(0130610),	one(0170770), "+s+d", m68000up },
 
 /* The cmp opcode can generate the cmpa, cmpm, and cmpi instructions.  */
-{"cmpb",	one(0006000),	one(0177700), "#b@s", m68000up },
+{"cmpb",	one(0006000),	one(0177700), "#b$s", m68000up },
 {"cmpb",	one(0006000),	one(0177700), "#bDs", mcf5407 },
 {"cmpb",	one(0130410),	one(0170770), "+s+d", m68000up },
 {"cmpb",	one(0130000),	one(0170700), ";bDd", m68000up },
 {"cmpb",	one(0130000),	one(0170700), "*bDd", mcf5407 },
 {"cmpw",	one(0130300),	one(0170700), "*wAd", m68000up },
-{"cmpw",	one(0006100),	one(0177700), "#w@s", m68000up },
+{"cmpw",	one(0006100),	one(0177700), "#w$s", m68000up },
 {"cmpw",	one(0006100),	one(0177700), "#wDs", mcf5407 },
 {"cmpw",	one(0130510),	one(0170770), "+s+d", m68000up },
 {"cmpw",	one(0130100),	one(0170700), "*wDd", m68000up | mcf5407 },
 {"cmpl",	one(0130700),	one(0170700), "*lAd", m68000up | mcf },
-{"cmpl",	one(0006200),	one(0177700), "#l@s", m68000up },
+{"cmpl",	one(0006200),	one(0177700), "#l$s", m68000up },
 {"cmpl",	one(0006200),	one(0177700), "#lDs", mcf },
 {"cmpl",	one(0130610),	one(0170770), "+s+d", m68000up },
 {"cmpl",	one(0130200),	one(0170700), "*lDd", m68000up | mcf },
@@ -1970,6 +1971,7 @@
 
 const struct m68k_opcode_alias m68k_opcode_aliases[] =
 {
+  { "abcdb",	"abcd", }, /* (TIGCC 20030901) */
   { "add",	"addw", },
   { "adda",	"addaw", },
   { "addi",	"addiw", },
@@ -2068,6 +2070,7 @@
   { "tdivsl",	"divsl", },
   { "divs",	"divsw", },
   { "divu",	"divuw", },
+  { "exgl",	"exg", }, /* (TIGCC 20020512, 20030901) */
   { "ext",	"extw", },
   { "extbw",	"extw", },
   { "extwl",	"extl", },
